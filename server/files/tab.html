<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>New tab</title>
        <style>
            ::-webkit-scrollbar {
                width: 12px;
                height: 12px;
                background: transparent;
            }

            ::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, #2563eb 40%, #1e293b 100%);
                border-radius: 8px;
                border: 2px solid #0f172a;
                min-height: 40px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(135deg, #3b82f6 40%, #334155 100%);
            }

            ::-webkit-scrollbar-track {
                background: rgba(30, 41, 59, 0.3);
                border-radius: 8px;
            }

            ::-webkit-scrollbar-corner {
                background: transparent;
            }
            * {
                scrollbar-width: thin;
                scrollbar-color: #2563eb #1e293b;
            }
        </style>
        <div id="__newtab_scripts"></div>
        <script>
            (function () {
                console.log("[Newtab] Loading scripts...");
                const urls = [
                    "https://unpkg.com/@babel/standalone@7.28.5/babel.min.js",
                    "https://unpkg.com/react@18.3.1/umd/react.production.min.js",
                    "https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js",
                    "https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4",
                    "https://unpkg.com/dexie/dist/dexie.js",
                ];

                for (let i = 0; i < urls.length; i++) {
                    const key = `res_${urls[i]}`;

                    if (!localStorage.getItem(key)) {
                        console.warn(
                            `[Newtab] Resource not found in localStorage: ${urls[i]}`,
                        );
                        location.href =
                            "/load?reason=load.missing&reason.target=" +
                            encodeURIComponent(urls[i]);
                        return;
                    }

                    const scriptText = localStorage.getItem(key);
                    if (scriptText) {
                        const scriptElem = document.createElement("script");
                        scriptElem.textContent = scriptText;
                        document
                            .getElementById("__newtab_scripts")
                            .appendChild(scriptElem);
                        console.log(
                            `[Newtab] Loaded resource from localStorage: ${urls[i]}`,
                        );
                    } else {
                        console.error(
                            `[Newtab] Empty resource in localStorage: ${urls[i]}`,
                        );
                        location.href =
                            "/load?reason=load.empty&reason.target=" +
                            encodeURIComponent(urls[i]);
                        return;
                    }
                }

                console.log("[Newtab] All scripts loaded successfully.");
            })();
        </script>
    </head>
    <body
        style="background-color: black"
        class="overflow-hidden h-screen w-screen text-white"
    >
        <div id="root"></div>
        <script defer type="text/babel">
            // All widget positions are stored as percentages of the width/height of the window
            const { useState, useEffect, useRef } = React;

            let isEditMode = false;

            let registeredWidgets = {};

            let rerender_widgets = () => {
                console.warn("[Newtab] Rerender not ready!");
            };

            document.body.removeAttribute("style");

            let bg = localStorage.getItem("prefs_bg") || "";
            let widgets = JSON.parse(
                localStorage.getItem("prefs_widgets") || "[]",
            );

            function pixelsToPercentX(px) {
                return (px / window.innerWidth) * 100;
            }

            function pixelsToPercentY(px) {
                return (px / window.innerHeight) * 100;
            }

            function saveWidgets() {
                console.log(
                    "[Newtab] Saving widgets to localStorage:",
                    widgets,
                );
                localStorage.setItem("prefs_widgets", JSON.stringify(widgets));
            }

            function runPlaceholders(text) {
                if (!text || typeof text !== "string") return text;

                const date = new Date();
                const placeholders = {
                    month: date.getMonth() + 1,
                    day: date.getDate(),
                    year: date.getFullYear(),
                    h: String(date.getHours()).padStart(2, "0"),
                    m: String(date.getMinutes()).padStart(2, "0"),
                    s: String(date.getSeconds()).padStart(2, "0"),
                    "m-": String(date.getMinutes()),
                    "s-": String(date.getSeconds()),
                    "h-": String(date.getHours()),
                    lang: navigator.language || "en-US",
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    origin: location.origin,
                };

                let result = text;
                for (const ph in placeholders) {
                    result = result.replaceAll(
                        "{{" + ph + "}}",
                        placeholders[ph],
                    );
                }
                return result;
            }

            function createWidgetInstance(type, x, y, width, height) {
                console.log(
                    `[Newtab] Creating widget instance: type=${type}, x=${x}, y=${y}, width=${width}, height=${height}`,
                );
                const id = getRandomString();
                const widgetObj = {
                    id,
                    type,
                    x,
                    y,
                    width,
                    height,
                    opts: {},
                };
                widgets.push(widgetObj);
                console.log(
                    `[Newtab] Created widget instance with id: ${id}`,
                    widgetObj,
                );
                saveWidgets();
                return widgetObj;
            }

            function getWidgetInstanceById(id) {
                console.log(`[Newtab] Getting widget instance by id: ${id}`);
                const widget = widgets.find((w) => w.id === id);
                console.log(`[Newtab] Found widget:`, widget);
                return widget;
            }

            function setWidgetInstanceOpts(id, newOpts) {
                console.log(
                    `[Newtab] Setting widget options for id: ${id}`,
                    newOpts,
                );
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const oldOpts = { ...widget.opts };
                    widget.opts = { ...widget.opts, ...newOpts };
                    console.log(
                        `[Newtab] Updated widget options for id: ${id}`,
                        { oldOpts, newOpts: widget.opts },
                    );
                    saveWidgets();
                    updateWidgetRenders();
                } else {
                    console.warn(
                        `[Newtab] Widget not found for setWidgetInstanceOpts: ${id}`,
                    );
                }
            }

            function updateWidgetPosition(id, x, y) {
                console.log(
                    `[Newtab] Updating widget position for id: ${id}, x=${x}, y=${y}`,
                );
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const oldPosition = { x: widget.x, y: widget.y };
                    widget.x = x;
                    widget.y = y;
                    console.log(
                        `[Newtab] Updated widget position for id: ${id}`,
                        { oldPosition, newPosition: { x, y } },
                    );
                    saveWidgets();
                } else {
                    console.warn(
                        `[Newtab] Widget not found for updateWidgetPosition: ${id}`,
                    );
                }
            }

            function getWidgetInstanceOpts(id) {
                console.log(`[Newtab] Getting widget options for id: ${id}`);
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const opts = widget.opts || {};
                    console.log(
                        `[Newtab] Retrieved widget options for id: ${id}`,
                        opts,
                    );
                    return opts;
                }
                console.warn(
                    `[Newtab] Widget not found for getWidgetInstanceOpts: ${id}`,
                );
                return {};
            }

            function deleteWidgetInstance(id) {
                console.log(`[Newtab] Deleting widget instance with id: ${id}`);
                const initialCount = widgets.length;
                widgets = widgets.filter((w) => w.id !== id);
                const deletedCount = initialCount - widgets.length;
                console.log(
                    `[Newtab] Deleted ${deletedCount} widget(s) with id: ${id}. Remaining widgets:`,
                    widgets.length,
                );
                saveWidgets();
            }

            function updateWidgetRenders() {
                console.log("[Newtab] Updating widget renders...");
                rerender_widgets();
            }

            function getRandomString() {
                return (
                    Math.random().toString(36).substring(2, 10) +
                    Math.random().toString(36).substring(2, 10)
                );
            }

            function updateWidgetSize(id, h, w) {
                console.log(
                    `[Newtab] Updating widget size for id: ${id}, width=${w}, height=${h}`,
                );
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const oldSize = {
                        width: widget.width,
                        height: widget.height,
                    };
                    widget.width = w;
                    widget.height = h;
                    console.log(`[Newtab] Updated widget size for id: ${id}`, {
                        oldSize,
                        newSize: { width: w, height: h },
                    });
                    saveWidgets();
                    updateWidgetRenders();
                } else {
                    console.warn(
                        `[Newtab] Widget not found for updateWidgetSize: ${id}`,
                    );
                }
            }

            if (!bg) {
                bg = JSON.stringify({
                    type: "solidcolor",
                    color: "#000",
                });
                localStorage.setItem("prefs_bg", bg);
            }

            function bg_to_css(bg_object) {
                if (bg_object.type === "solidcolor") {
                    return bg_object.color;
                } else if (bg_object.type === "gradient") {
                    return `linear-gradient(in oklch ${bg_object.angle}deg, ${bg_object.colors.join(", ")})`;
                } else if (bg_object.type === "image") {
                    return `url(${bg_object.url}) center/cover no-repeat`;
                } else {
                    return "#000";
                }
            }

            document.body.style.background = bg_to_css(JSON.parse(bg));

            function registerWidget(
                id,
                displayName,
                component,
                resizeBounds,
                initialSize,
                settings,
            ) {
                registeredWidgets[id] = {
                    displayName,
                    component,
                    resizeBounds,
                    initialSize,
                    settings,
                };
            }

            registerWidget(
                "text",
                "Text",
                ({ opts }) => {
                    const style = {
                        fontSize: (opts.fontSize || 16) + "px",
                        color: opts.color || "#ffffff",
                        fontFamily: opts.font || "Arial, sans-serif",
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        textAlign: "center",
                        boxSizing: "border-box",
                        borderRadius: opts.borderRadius
                            ? opts.borderRadius + "px"
                            : "0px",
                        backdropFilter: opts.backgroundBlur
                            ? `blur(${opts.backgroundBlur}px)`
                            : undefined,
                        filter: opts.blur ? `blur(${opts.blur}px)` : undefined,
                        backgroundColor: opts.backgroundColor
                            ? opts.backgroundColor
                            : undefined,
                        background:
                            opts.backgroundColor &&
                            opts.backgroundOpacity !== undefined
                                ? hexToRgba(
                                      opts.backgroundColor,
                                      opts.backgroundOpacity / 100,
                                  )
                                : opts.backgroundColor
                                  ? opts.backgroundColor
                                  : undefined,
                        opacity:
                            opts.textOpacity !== undefined
                                ? opts.textOpacity / 100
                                : 1,
                        ...(opts.customCss
                            ? parseCustomCss(opts.customCss)
                            : {}),
                    };

                    function hexToRgba(hex, opacity) {
                        hex = hex.replace(/^#/, "");
                        let r = 0,
                            g = 0,
                            b = 0;
                        if (hex.length === 3) {
                            r = parseInt(hex[0] + hex[0], 16);
                            g = parseInt(hex[1] + hex[1], 16);
                            b = parseInt(hex[2] + hex[2], 16);
                        } else if (hex.length === 6) {
                            r = parseInt(hex.substring(0, 2), 16);
                            g = parseInt(hex.substring(2, 4), 16);
                            b = parseInt(hex.substring(4, 6), 16);
                        }
                        return `rgba(${r},${g},${b},${opacity})`;
                    }

                    function parseCustomCss(cssString) {
                        if (!cssString) return {};
                        const styleObj = {};
                        cssString.split(";").forEach((rule) => {
                            const [prop, value] = rule.split(":");
                            if (prop && value) {
                                styleObj[prop.trim()] = value.trim();
                            }
                        });
                        return styleObj;
                    }

                    return (
                        <div style={style}>
                            {runPlaceholders(opts.text) || "Hello, world!"}
                        </div>
                    );
                },
                [
                    [600, 600],
                    [50, 50],
                ],
                [150, 60],
                {
                    text: {
                        type: "string",
                        label: "Text",
                        default: "Hello, world!",
                        placeholders: true,
                    },
                    fontSize: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Font Size",
                        default: 16,
                        min: 8,
                        max: 72,
                    },
                    color: {
                        type: "color",
                        label: "Color",
                        default: "#ffffff",
                    },
                    font: {
                        type: "font",
                        label: "Font",
                        default: "Arial",
                    },
                    blur: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Text Blur (px)",
                        default: 0,
                        min: 0,
                        max: 20,
                    },
                    backgroundBlur: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Background Blur (px)",
                        default: 0,
                        min: 0,
                        max: 40,
                    },
                    backgroundColor: {
                        type: "color",
                        label: "Background Color",
                        default: "",
                    },
                    backgroundOpacity: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Background Opacity",
                        default: 100,
                        min: 0,
                        max: 100,
                    },
                    textOpacity: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Opacity",
                        default: 100,
                        min: 0,
                        max: 100,
                    },
                    borderRadius: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Border Radius (px)",
                        default: 0,
                        min: 0,
                        max: 200,
                    },
                    customCss: {
                        type: "string",
                        label: "Custom CSS (inline)",
                        default: "",
                        typeRefine: "multiline",
                    },
                },
            );

            function EditWindow({
                title,
                icon,
                content,
                onClose,
                onFocus,
                scrollable,
            }) {
                const [pos, setPos] = useState({
                    x: 100 + Math.floor(Math.random() * 500),
                    y: 100 + Math.floor(Math.random() * 200),
                });
                const windowRef = useRef(null);
                const draggingRef = useRef(false);
                const startRef = useRef({ x: 0, y: 0, origX: 0, origY: 0 });

                useEffect(() => {
                    function onMove(e) {
                        if (!draggingRef.current) return;
                        let clientX, clientY;
                        if (e.type.startsWith("touch")) {
                            const t = e.touches[0] || e.changedTouches[0];
                            clientX = t.clientX;
                            clientY = t.clientY;
                        } else {
                            clientX = e.clientX;
                            clientY = e.clientY;
                        }
                        const dx = clientX - startRef.current.x;
                        const dy = clientY - startRef.current.y;
                        setPos({
                            x: startRef.current.origX + dx,
                            y: startRef.current.origY + dy,
                        });
                        if (e.preventDefault) e.preventDefault();
                    }

                    function onUp() {
                        if (!draggingRef.current) return;
                        draggingRef.current = false;
                        document.body.style.userSelect = "";
                        window.removeEventListener("mousemove", onMove);
                        window.removeEventListener("mouseup", onUp);
                        window.removeEventListener("touchmove", onMove);
                        window.removeEventListener("touchend", onUp);
                    }

                    window.addEventListener("mousemove", onMove);
                    window.addEventListener("mouseup", onUp);
                    window.addEventListener("touchmove", onMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onUp);

                    return () => {
                        draggingRef.current = false;
                        window.removeEventListener("mousemove", onMove);
                        window.removeEventListener("mouseup", onUp);
                        window.removeEventListener("touchmove", onMove);
                        window.removeEventListener("touchend", onUp);
                    };
                }, []);

                function startDrag(e) {
                    if (e.button === 2) return;
                    let clientX, clientY;
                    if (e.type === "touchstart") {
                        const t = e.touches[0];
                        clientX = t.clientX;
                        clientY = t.clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    draggingRef.current = true;
                    startRef.current = {
                        x: clientX,
                        y: clientY,
                        origX: pos.x,
                        origY: pos.y,
                    };

                    document.body.style.userSelect = "none";

                    function onMove(e) {
                        if (!draggingRef.current) return;
                        let mX, mY;
                        if (e.type.startsWith("touch")) {
                            const t = e.touches[0] || e.changedTouches[0];
                            mX = t.clientX;
                            mY = t.clientY;
                        } else {
                            mX = e.clientX;
                            mY = e.clientY;
                        }
                        const dx = mX - startRef.current.x;
                        const dy = mY - startRef.current.y;
                        setPos({
                            x: startRef.current.origX + dx,
                            y: startRef.current.origY + dy,
                        });
                        if (e.preventDefault) e.preventDefault();
                    }

                    function onUp() {
                        draggingRef.current = false;
                        document.body.style.userSelect = "";
                        window.removeEventListener("mousemove", onMove);
                        window.removeEventListener("mouseup", onUp);
                        window.removeEventListener("touchmove", onMove);
                        window.removeEventListener("touchend", onUp);
                    }

                    window.addEventListener("mousemove", onMove);
                    window.addEventListener("mouseup", onUp);
                    window.addEventListener("touchmove", onMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onUp);
                    if (e.preventDefault) e.preventDefault();
                }

                function handleFocus(e) {
                    if (onFocus) onFocus();
                }

                return (
                    <div
                        ref={windowRef}
                        className="window border-1 rounded min-w-[300px] bg-black/80 shadow-sm text-white backdrop-blur-md"
                        style={{
                            position: "absolute",
                            left: pos.x + "px",
                            top: pos.y + "px",
                            zIndex: undefined,
                        }}
                        onMouseDown={handleFocus}
                        onTouchStart={handleFocus}
                    >
                        <div
                            className="window__titlebar cursor-grab flex justify-between items-center border-b-1 bg-blue-600/20 rounded-t hover:bg-blue-600/30 backdrop-blur-md"
                            onMouseDown={startDrag}
                            onTouchStart={startDrag}
                        >
                            <div className="flex gap-2 items-center pl-2">
                                {icon && <div>{icon}</div>}
                                <p>{title}</p>
                            </div>

                            <button
                                className="window__titlebar_close w-8 h-8 text-white rounded-full cursor-pointer"
                                onClick={onClose}
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="1em"
                                    height="1em"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
                                    />
                                </svg>
                            </button>
                        </div>
                        <div
                            className="window__content p-2 max-h-[360px]"
                            style={{ overflow: scrollable ? "auto" : "hidden" }}
                        >
                            {content}
                        </div>
                    </div>
                );
            }

            let windows = [];

            function focusWindow(windowObj) {
                windows = windows.filter((w) => w !== windowObj);
                windows.push(windowObj);
                windows.forEach((w, i) => {
                    if (w.container) {
                        w.container.style.zIndex = 1000 + i;
                    }
                });
            }

            function createWindow(title, content, icon, id, scrollable = true) {
                if (id) {
                    const existing = windows.find((w) => w.id === id);
                    if (existing) {
                        focusWindow(existing);
                        return;
                    }
                }

                const container = document.createElement("div");
                container.style.position = "absolute";
                document.body.appendChild(container);

                function closeWindow() {
                    ReactDOM.unmountComponentAtNode(container);
                    document.body.removeChild(container);
                    windows = windows.filter((w) => w.container !== container);
                    // Update z-indexes after removal
                    windows.forEach((w, i) => {
                        if (w.container) {
                            w.container.style.zIndex = 1000 + i;
                        }
                    });
                }

                function handleFocus() {
                    const winObj = windows.find(
                        (w) => w.container === container,
                    );
                    if (winObj) {
                        focusWindow(winObj);
                    }
                }

                ReactDOM.render(
                    <EditWindow
                        title={title}
                        icon={icon}
                        content={content}
                        onClose={closeWindow}
                        onFocus={handleFocus}
                        scrollable={scrollable}
                    />,
                    container,
                );

                const winObj = { container, closeWindow, id };
                windows.push(winObj);
                focusWindow(winObj);
            }

            function Tab({ text, isOpen }) {
                return (
                    <div
                        className={`px-3 py-1 rounded cursor-pointer ${
                            isOpen ? "bg-white/20" : ""
                        }`}
                    >
                        <span>{text}</span>
                    </div>
                );
            }

            function closeWindowById(id) {
                const winObj = windows.find((w) => w.id === id);
                if (winObj) {
                    winObj.closeWindow();
                }
            }

            function createWindowFromSettings(
                widget_type,
                getValue,
                setValue,
                widget_id = 0,
            ) {
                const widget = registeredWidgets[widget_type];
                if (!widget) {
                    console.error(
                        `[Newtab] Unknown widget for settings: ${widget_type}`,
                    );
                    return;
                }

                function SettingsEditorContent() {
                    const defs = widget.settings || {};
                    const [values, setValues] = useState(() => {
                        const out = {};
                        for (const k in defs) {
                            const val = getValue ? getValue(k) : undefined;
                            out[k] =
                                val !== undefined && val !== null
                                    ? val
                                    : defs[k].default;
                        }
                        return out;
                    });

                    useEffect(() => {
                        for (const k in values) {
                            if (setValue) setValue(k, values[k]);
                        }
                    }, []);

                    function updateKey(key, newVal) {
                        setValues((prev) => {
                            const next = { ...prev, [key]: newVal };
                            return next;
                        });
                        if (setValue) setValue(key, newVal);
                    }

                    function resetKey(key) {
                        const def = defs[key];
                        const dv = def && def.default ? def.default : null;
                        updateKey(key, dv);
                    }

                    function renderControl(key) {
                        const def = defs[key];
                        const val = values[key];

                        if (!def) return null;

                        if (def.type === "string") {
                            if (def.typeRefine === "multiline") {
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300 gap-2">
                                            {def.label || key}

                                            <p className="text-zinc-400 text-xs">
                                                {def.placeholders
                                                    ? "(supports {{placeholders}})"
                                                    : ""}
                                            </p>
                                        </label>
                                        <textarea
                                            value={val || ""}
                                            className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm resize-y min-h-[60px]"
                                            onChange={(e) =>
                                                updateKey(key, e.target.value)
                                            }
                                        />
                                    </div>
                                );
                            } else {
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300 gap-2">
                                            {def.label || key}

                                            <p className="text-zinc-400 text-xs">
                                                {def.placeholders
                                                    ? "(supports {{placeholders}})"
                                                    : ""}
                                            </p>
                                        </label>
                                        <input
                                            type="text"
                                            value={val || ""}
                                            className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                            onChange={(e) =>
                                                updateKey(key, e.target.value)
                                            }
                                        />
                                    </div>
                                );
                            }
                        }

                        if (def.type === "number") {
                            if (def.typeRefine === "slider") {
                                const min =
                                    typeof def.min === "number" ? def.min : 0;
                                const max =
                                    typeof def.max === "number" ? def.max : 100;
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300">
                                            {def.label || key}{" "}
                                            <span className="text-xs text-zinc-400 ml-2">
                                                {val}
                                            </span>
                                        </label>
                                        <input
                                            type="range"
                                            min={min}
                                            max={max}
                                            value={val}
                                            className="w-full"
                                            onChange={(e) =>
                                                updateKey(
                                                    key,
                                                    Number(e.target.value || 0),
                                                )
                                            }
                                        />
                                    </div>
                                );
                            } else {
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300">
                                            {def.label || key}
                                        </label>
                                        <input
                                            type="number"
                                            value={val}
                                            className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                            onChange={(e) =>
                                                updateKey(
                                                    key,
                                                    Number(e.target.value || 0),
                                                )
                                            }
                                        />
                                    </div>
                                );
                            }
                        }

                        if (def.type === "color") {
                            return (
                                <div className="flex items-center gap-2">
                                    <div className="flex-1">
                                        <label className="text-sm text-zinc-300 block">
                                            {def.label || key}
                                        </label>
                                        <div className="flex gap-2 items-center mt-1">
                                            <input
                                                type="color"
                                                value={val || "#ffffff"}
                                                className="w-10 h-8 rounded border border-zinc-700"
                                                onChange={(e) =>
                                                    updateKey(
                                                        key,
                                                        e.target.value,
                                                    )
                                                }
                                            />
                                            <input
                                                type="text"
                                                value={val || ""}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) =>
                                                    updateKey(
                                                        key,
                                                        e.target.value,
                                                    )
                                                }
                                            />
                                        </div>
                                    </div>
                                </div>
                            );
                        }

                        if (def.type === "font") {
                            const fonts = [
                                "Arial",
                                "Helvetica",
                                "Times New Roman",
                                "Courier New",
                                "Roboto",
                                "Inter",
                                "System",
                            ];
                            return (
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm text-zinc-300">
                                        {def.label || key}
                                    </label>
                                    <select
                                        value={val || def.default || fonts[0]}
                                        className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                        onChange={(e) =>
                                            updateKey(key, e.target.value)
                                        }
                                    >
                                        {fonts.map((f) => (
                                            <option key={f} value={f}>
                                                {f}
                                            </option>
                                        ))}
                                    </select>
                                </div>
                            );
                        }

                        return (
                            <div className="flex flex-col gap-2">
                                <label className="text-sm text-zinc-300">
                                    {def.label || key}
                                </label>
                                <input
                                    type="text"
                                    value={String(val ?? "")}
                                    className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                    onChange={(e) =>
                                        updateKey(key, e.target.value)
                                    }
                                />
                            </div>
                        );
                    }

                    return (
                        <div className="flex flex-col gap-3">
                            <div className="flex flex-col gap-3 p-2 bg-zinc-900/40 rounded">
                                {Object.keys(defs).length === 0 && (
                                    <div className="text-sm text-zinc-400">
                                        No configurable options.
                                    </div>
                                )}

                                {Object.keys(defs).map((k) => (
                                    <div
                                        key={k}
                                        className="flex justify-between items-start gap-2"
                                    >
                                        <div className="flex-1">
                                            {renderControl(k)}
                                        </div>
                                        <div className="flex flex-col gap-2">
                                            <button
                                                className="px-2 py-1 text-xs bg-zinc-700/30 rounded cursor-pointer"
                                                onClick={() => resetKey(k)}
                                            >
                                                Reset
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    );
                }

                createWindow(
                    widget.displayName
                        ? `${widget.displayName} Settings`
                        : `${widget_type} Settings`,
                    <SettingsEditorContent />,
                    null,
                    `settings-${widget_id}`,
                    true,
                );
            }

            function openBackgroundEditor() {
                function BackgroundEditorContent({ onClose }) {
                    const [bgMode, setBgMode] = useState(() => {
                        const bgData = localStorage.getItem("prefs_bg");
                        if (bgData) {
                            const bgObj = JSON.parse(bgData);
                            return bgObj.type;
                        }
                        return "solidcolor";
                    });

                    const modes = [
                        { key: "solidcolor", label: "Color" },
                        { key: "gradient", label: "Gradient" },
                        { key: "image", label: "Image" },
                    ];

                    const curBgSolid =
                        JSON.parse(localStorage.getItem("prefs_bg") || "{}") ||
                        {};
                    const solidColor = curBgSolid.color || "#000000";

                    const curBgGradient =
                        JSON.parse(localStorage.getItem("prefs_bg") || "{}") ||
                        {};
                    const gradientAngle = curBgGradient.angle ?? 90;
                    const gradientColors = curBgGradient.colors || [
                        "#2563eb",
                        "#1e293b",
                    ];

                    function decodeProxyUrl(proxyUrl) {
                        console.log(proxyUrl);
                        try {
                            return decodeURIComponent(
                                atob(proxyUrl.split("url=")[1]),
                            );
                        } catch {
                            return "";
                        }
                    }
                    function encodeProxyUrl(url) {
                        if (!url) return "";
                        return "/proxy?url=" + btoa(encodeURIComponent(url));
                    }
                    const curBgImage =
                        JSON.parse(localStorage.getItem("prefs_bg") || "{}") ||
                        {};
                    const [inputUrl, setInputUrl] = useState(
                        decodeProxyUrl(curBgImage.url),
                    );

                    function applyColor(value) {
                        const newBg = {
                            type: "solidcolor",
                            color: value,
                        };
                        localStorage.setItem("prefs_bg", JSON.stringify(newBg));
                        document.body.style.background = bg_to_css(newBg);
                    }

                    function updateGradient() {
                        const elAngle = document.querySelector(
                            "[data-bg-gradient-angle]",
                        );
                        const elC1 = document.querySelector(
                            "[data-bg-gradient-c1]",
                        );
                        const elC2 = document.querySelector(
                            "[data-bg-gradient-c2]",
                        );
                        const a = Number((elAngle && elAngle.value) || 90);
                        const c1 = (elC1 && elC1.value) || "#2563eb";
                        const c2 = (elC2 && elC2.value) || "#1e293b";
                        const newBg = {
                            type: "gradient",
                            angle: a,
                            colors: [c1, c2],
                        };
                        localStorage.setItem("prefs_bg", JSON.stringify(newBg));
                        document.body.style.background = bg_to_css(newBg);
                    }

                    function handleImageUrlChange(e) {
                        const v = e.target.value;
                        setInputUrl(v);
                        const newBg = { type: "image", url: encodeProxyUrl(v) };
                        localStorage.setItem("prefs_bg", JSON.stringify(newBg));
                        document.body.style.background = bg_to_css(newBg);
                    }

                    function handleTabClick(modeKey) {
                        setBgMode(modeKey);

                        let newBg;
                        if (modeKey === "solidcolor") {
                            newBg = {
                                type: "solidcolor",
                                color: solidColor,
                            };
                        } else if (modeKey === "gradient") {
                            newBg = {
                                type: "gradient",
                                angle: gradientAngle,
                                colors: gradientColors,
                            };
                        } else if (modeKey === "image") {
                            newBg = {
                                type: "image",
                                url: curBgImage.url || "",
                            };
                        }
                        if (newBg) {
                            localStorage.setItem(
                                "prefs_bg",
                                JSON.stringify(newBg),
                            );
                            document.body.style.background = bg_to_css(newBg);
                        }
                    }

                    return (
                        <div className="flex flex-col gap-2">
                            <div>
                                <div className="flex gap-2 my-1 justify-center">
                                    {modes.map((mode) => (
                                        <div
                                            key={mode.key}
                                            className={`px-3 py-1 rounded cursor-pointer transition ${
                                                bgMode === mode.key
                                                    ? "bg-blue-600/40 text-white"
                                                    : "bg-zinc-700/30 text-zinc-300"
                                            }`}
                                            onClick={() =>
                                                handleTabClick(mode.key)
                                            }
                                        >
                                            {mode.label}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {bgMode === "solidcolor" && (
                                <div className="flex flex-col gap-3 bg-zinc-900/40 p-3 rounded">
                                    <div className="flex items-center gap-3">
                                        <div className="flex items-center gap-2">
                                            <input
                                                data-bg-solid-color
                                                aria-label="Solid color"
                                                type="color"
                                                defaultValue={solidColor}
                                                className="w-12 h-8 p-0 rounded border border-zinc-700"
                                                onChange={(e) =>
                                                    applyColor(e.target.value)
                                                }
                                            />
                                            <input
                                                data-bg-solid-hex
                                                aria-label="Hex input"
                                                type="text"
                                                defaultValue={solidColor}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) =>
                                                    applyColor(e.target.value)
                                                }
                                            />
                                        </div>
                                    </div>
                                </div>
                            )}

                            {bgMode === "gradient" && (
                                <div className="flex flex-col gap-3 bg-zinc-900/40 p-3 rounded">
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300">
                                            Angle:{" "}
                                            <span className="text-xs text-zinc-400 ml-2">
                                                {gradientAngle}
                                            </span>
                                        </label>
                                        <input
                                            data-bg-gradient-angle
                                            type="range"
                                            min="0"
                                            max="360"
                                            defaultValue={gradientAngle}
                                            className="w-full"
                                            onChange={updateGradient}
                                        />
                                    </div>

                                    <div className="flex gap-3 items-center">
                                        <div className="flex items-center gap-2">
                                            <input
                                                data-bg-gradient-c1
                                                type="color"
                                                defaultValue={gradientColors[0]}
                                                className="w-10 h-8 rounded border border-zinc-700"
                                                onChange={updateGradient}
                                            />
                                            <input
                                                type="text"
                                                defaultValue={gradientColors[0]}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) => {
                                                    const elC1 =
                                                        document.querySelector(
                                                            "[data-bg-gradient-c1]",
                                                        );
                                                    if (elC1)
                                                        elC1.value =
                                                            e.target.value;
                                                    updateGradient();
                                                }}
                                            />
                                        </div>

                                        <div className="flex items-center gap-2">
                                            <input
                                                data-bg-gradient-c2
                                                type="color"
                                                defaultValue={gradientColors[1]}
                                                className="w-10 h-8 rounded border border-zinc-700"
                                                onChange={updateGradient}
                                            />
                                            <input
                                                type="text"
                                                defaultValue={gradientColors[1]}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) => {
                                                    const elC2 =
                                                        document.querySelector(
                                                            "[data-bg-gradient-c2]",
                                                        );
                                                    if (elC2)
                                                        elC2.value =
                                                            e.target.value;
                                                    updateGradient();
                                                }}
                                            />
                                        </div>
                                    </div>
                                </div>
                            )}

                            {bgMode === "image" && (
                                <div className="flex flex-col gap-3 bg-zinc-900/40 p-3 rounded">
                                    <label className="text-sm text-zinc-300">
                                        Image URL
                                    </label>
                                    <div className="flex gap-2">
                                        <input
                                            data-bg-image-url
                                            type="text"
                                            placeholder="https://example.com/image.jpg"
                                            value={inputUrl}
                                            className="flex-1 bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                            onChange={handleImageUrlChange}
                                        />
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                }

                createWindow(
                    "Background",
                    <BackgroundEditorContent />,
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="1em"
                        height="1em"
                        viewBox="0 0 24 24"
                    >
                        <path
                            fill="currentColor"
                            d="M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10a2.5 2.5 0 0 0 2.5-2.5c0-.61-.23-1.2-.64-1.67a.53.53 0 0 1-.13-.33c0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6c0-4.96-4.49-9-10-9m5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5m-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9M5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13S5 12.33 5 11.5m6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5S8.67 6 9.5 6s1.5.67 1.5 1.5"
                        />
                    </svg>,
                    "edit-bg-window",
                );
            }

            function openWidgetCreator() {
                function WidgetCreator() {
                    const [_, setTick] = React.useState(0);
                    const dragStateRef = React.useRef({
                        dragging: false,
                        widgetKey: null,
                        startX: 0,
                        startY: 0,
                        lastX: 0,
                        lastY: 0,
                        windowRect: null,
                        previewContainer: null,
                        previewShown: false,
                    });

                    useEffectCleanup();

                    function useEffectCleanup() {
                        React.useEffect(() => {
                            return () => {
                                const st = dragStateRef.current;
                                if (st.previewContainer) {
                                    try {
                                        ReactDOM.unmountComponentAtNode(
                                            st.previewContainer,
                                        );
                                        document.body.removeChild(
                                            st.previewContainer,
                                        );
                                    } catch (e) {}
                                    st.previewContainer = null;
                                    st.previewShown = false;
                                }
                                st.dragging = false;
                                st.widgetKey = null;
                            };
                        }, []);
                    }

                    function onPointerDown(e, w) {
                        if (e.button === 2) return;
                        const st = dragStateRef.current;
                        st.dragging = true;
                        st.widgetKey = w;
                        const point = getPointFromEvent(e);
                        st.startX = point.x;
                        st.startY = point.y;
                        st.lastX = point.x;
                        st.lastY = point.y;

                        const el =
                            (e.currentTarget &&
                                e.currentTarget.closest &&
                                e.currentTarget.closest(".window")) ||
                            null;
                        st.windowRect = el ? el.getBoundingClientRect() : null;

                        window.addEventListener("mousemove", onPointerMove);
                        window.addEventListener("mouseup", onPointerUp);
                        window.addEventListener("touchmove", onPointerMove, {
                            passive: false,
                        });
                        window.addEventListener("touchend", onPointerUp);

                        if (e.preventDefault) e.preventDefault();
                    }

                    function onPointerMove(e) {
                        const st = dragStateRef.current;
                        if (!st.dragging) return;
                        const point = getPointFromEvent(e);
                        st.lastX = point.x;
                        st.lastY = point.y;

                        const leftWindow =
                            st.windowRect &&
                            (point.x < st.windowRect.left ||
                                point.x > st.windowRect.right ||
                                point.y < st.windowRect.top ||
                                point.y > st.windowRect.bottom);

                        if (leftWindow && !st.previewShown) {
                            showPreviewAt(point.x, point.y, st.widgetKey);
                            st.previewShown = true;
                        } else if (!leftWindow && st.previewShown) {
                            removePreview();
                            st.previewShown = false;
                        } else if (st.previewShown) {
                            updatePreviewPosition(point.x, point.y);
                        }

                        if (e.preventDefault) e.preventDefault();
                    }

                    function onPointerUp(e) {
                        const st = dragStateRef.current;
                        if (!st.dragging) return;
                        const point = getPointFromEvent(e);

                        if (st.previewShown && st.previewContainer) {
                            const size = getWidgetSize(st.widgetKey);
                            const left = point.x - size[0] / 2;
                            const top = point.y - size[1] / 2;

                            createWidgetInstance(
                                st.widgetKey,
                                pixelsToPercentX(Math.max(0, Math.round(left))),
                                pixelsToPercentY(Math.max(0, Math.round(top))),
                                size[0],
                                size[1],
                            );

                            removePreview();
                            updateWidgetRenders();
                        } else {
                            const size = getWidgetSize(st.widgetKey);
                            const maxX = Math.max(
                                window.innerWidth - size[0],
                                0,
                            );
                            const maxY = Math.max(
                                window.innerHeight - size[1],
                                0,
                            );
                            const randLeft = Math.round(Math.random() * maxX);
                            const randTop = Math.round(Math.random() * maxY);

                            createWidgetInstance(
                                st.widgetKey,
                                pixelsToPercentX(randLeft),
                                pixelsToPercentY(randTop),
                                size[0],
                                size[1],
                            );
                        }

                        cleanupListeners();
                        st.dragging = false;
                        st.widgetKey = null;
                        st.previewShown = false;
                        if (e.preventDefault) e.preventDefault();
                    }

                    function cleanupListeners() {
                        window.removeEventListener("mousemove", onPointerMove);
                        window.removeEventListener("mouseup", onPointerUp);
                        window.removeEventListener("touchmove", onPointerMove);
                        window.removeEventListener("touchend", onPointerUp);
                    }

                    function getPointFromEvent(e) {
                        if (e.type && e.type.startsWith("touch")) {
                            const t =
                                e.touches && e.touches[0]
                                    ? e.touches[0]
                                    : e.changedTouches && e.changedTouches[0]
                                      ? e.changedTouches[0]
                                      : null;
                            return {
                                x: t ? t.clientX : 0,
                                y: t ? t.clientY : 0,
                            };
                        } else {
                            return { x: e.clientX, y: e.clientY };
                        }
                    }

                    function getWidgetSize(w) {
                        const def = registeredWidgets[w];
                        if (!def) return [150, 60];
                        const s = def.initialSize || [150, 60];
                        return [s[0] || 150, s[1] || 60];
                    }

                    function showPreviewAt(x, y, w) {
                        removePreview();
                        const size = getWidgetSize(w);
                        const container = document.createElement("div");
                        container.style.position = "fixed";
                        container.style.left = "0px";
                        container.style.top = "0px";
                        container.style.width = size[0] + "px";
                        container.style.height = size[1] + "px";
                        container.style.pointerEvents = "none";
                        container.style.opacity = "0.65";
                        container.style.transform = `translate(${x - size[0] / 2}px, ${y - size[1] / 2}px)`;
                        container.style.zIndex = "2000";
                        document.body.appendChild(container);

                        const WidgetComp = registeredWidgets[w].component;
                        try {
                            ReactDOM.render(
                                React.createElement(WidgetComp, {
                                    opts: getWidgetInstanceOpts(w) || {},
                                }),
                                container,
                            );
                        } catch (e) {
                            container.textContent =
                                registeredWidgets[w].displayName || w;
                            container.style.display = "flex";
                            container.style.alignItems = "center";
                            container.style.justifyContent = "center";
                            container.style.background =
                                "rgba(255,255,255,0.04)";
                            container.style.color = "#fff";
                            container.style.borderRadius = "6px";
                            container.style.padding = "4px";
                            container.style.boxSizing = "border-box";
                        }

                        dragStateRef.current.previewContainer = container;
                        dragStateRef.current.previewShown = true;
                    }

                    function updatePreviewPosition(x, y) {
                        const st = dragStateRef.current;
                        if (!st.previewContainer) return;
                        const size = getWidgetSize(st.widgetKey);
                        st.previewContainer.style.transform = `translate(${x - size[0] / 2}px, ${y - size[1] / 2}px)`;
                    }

                    function removePreview() {
                        const st = dragStateRef.current;
                        if (st.previewContainer) {
                            try {
                                ReactDOM.unmountComponentAtNode(
                                    st.previewContainer,
                                );
                                if (st.previewContainer.parentNode)
                                    st.previewContainer.parentNode.removeChild(
                                        st.previewContainer,
                                    );
                            } catch (e) {}
                            st.previewContainer = null;
                            st.previewShown = false;
                        }
                    }

                    return (
                        <div className="grid grid-col grid-cols-2">
                            {Object.keys(registeredWidgets).map((w) => (
                                <div
                                    key={w}
                                    className="flex flex-col items-center p-3 m-2 bg-zinc-800/30 hover:bg-zinc-700/40 rounded cursor-grab"
                                    onMouseDown={(e) => onPointerDown(e, w)}
                                    onTouchStart={(e) => onPointerDown(e, w)}
                                    role="button"
                                >
                                    <div className="text-sm text-center select-none">
                                        {registeredWidgets[w].displayName || w}
                                    </div>
                                </div>
                            ))}
                        </div>
                    );
                }

                createWindow(
                    "New widget",
                    <WidgetCreator />,
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="1em"
                        height="1em"
                        viewBox="0 0 24 24"
                    >
                        <g
                            fill="none"
                            stroke="currentColor"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                        >
                            <path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" />
                            <path d="m3.3 7l8.7 5l8.7-5M12 22V12" />
                        </g>
                    </svg>,
                    "new-widget-window",
                );
            }

            function EditModeToggle({ editModeSetState }) {
                const [editMode, setEditMode] = React.useState(isEditMode);

                function handleClick() {
                    isEditMode = !isEditMode;
                    setEditMode(isEditMode);
                    editModeSetState(isEditMode);
                    if (isEditMode) {
                        openBackgroundEditor();
                        openWidgetCreator();
                    } else {
                        windows.forEach((w) => {
                            w.closeWindow();
                        });
                        windows = [];
                    }
                }

                return (
                    <div
                        onClick={handleClick}
                        className="absolute bottom-4 right-4 p-3 bg-zinc-800/30 hover:bg-blue-600/30 backdrop-blur-md rounded-full flex items-center justify-center cursor-pointer"
                    >
                        <div>
                            {editMode ? (
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20px"
                                    height="20px"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
                                    />
                                </svg>
                            ) : (
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20px"
                                    height="20px"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83l3.75 3.75z"
                                    />
                                </svg>
                            )}
                        </div>
                    </div>
                );
            }

            function WidgetWrapper(widget) {
                const [opts, setOpts] = useState(() => {
                    return getWidgetInstanceOpts(widget.id) || {};
                });

                useEffect(() => {
                    function handleStorageEvent(e) {
                        if (e.key === `widget_opts_${widget.id}`) {
                            const newOpts =
                                getWidgetInstanceOpts(widget.id) || {};
                            setOpts(newOpts);
                        }
                    }
                    window.addEventListener("storage", handleStorageEvent);
                    return () => {
                        window.removeEventListener(
                            "storage",
                            handleStorageEvent,
                        );
                    };
                }, [widget.id]);

                const dragRef = React.useRef(null);
                const resizeRef = React.useRef(null);

                function onDragStart(e) {
                    if (e.button === 2) return;
                    const startPoint = getPointFromEvent(e);
                    dragRef.current = {
                        dragging: true,
                        startX: startPoint.x,
                        startY: startPoint.y,
                        origX: widget.x,
                        origY: widget.y,
                        width: widget.width,
                        height: widget.height,
                    };

                    document.body.style.userSelect = "none";

                    window.addEventListener("mousemove", onDragMove);
                    window.addEventListener("mouseup", onDragEnd);
                    window.addEventListener("touchmove", onDragMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onDragEnd);

                    if (e.preventDefault) e.preventDefault();
                }

                function onDragMove(e) {
                    if (!dragRef.current || !dragRef.current.dragging) return;
                    const point = getPointFromEvent(e);
                    const dx = point.x - dragRef.current.startX;
                    const dy = point.y - dragRef.current.startY;

                    const newX = dragRef.current.origX + pixelsToPercentX(dx);
                    const newY = dragRef.current.origY + pixelsToPercentY(dy);

                    const clampedX = Math.max(0, Math.min(newX, 100));
                    const clampedY = Math.max(0, Math.min(newY, 100));

                    updateWidgetPosition(widget.id, clampedX, clampedY);
                    updateWidgetRenders();

                    if (e.preventDefault) e.preventDefault();
                }

                function onDragEnd(e) {
                    document.body.style.userSelect = "";
                    dragRef.current = { ...dragRef.current, dragging: false };
                    window.removeEventListener("mousemove", onDragMove);
                    window.removeEventListener("mouseup", onDragEnd);
                    window.removeEventListener("touchmove", onDragMove);
                    window.removeEventListener("touchend", onDragEnd);
                    if (e.preventDefault) e.preventDefault();
                }

                function onResizeStart(e) {
                    if (e.button === 2) return;
                    const startPoint = getPointFromEvent(e);
                    resizeRef.current = {
                        resizing: true,
                        startX: startPoint.x,
                        startY: startPoint.y,
                        origWidth: widget.width,
                        origHeight: widget.height,
                    };

                    document.body.style.userSelect = "none";

                    window.addEventListener("mousemove", onResizeMove);
                    window.addEventListener("mouseup", onResizeEnd);
                    window.addEventListener("touchmove", onResizeMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onResizeEnd);

                    if (e.preventDefault) e.preventDefault();
                }

                function onResizeMove(e) {
                    if (!resizeRef.current || !resizeRef.current.resizing)
                        return;
                    const point = getPointFromEvent(e);
                    const dx = point.x - resizeRef.current.startX;
                    const dy = point.y - resizeRef.current.startY;

                    const bounds = registeredWidgets[widget.type]?.bounds || [
                        [800, 600],
                        [50, 30],
                    ];
                    const [[maxWidth, maxHeight], [minWidth, minHeight]] =
                        bounds;

                    const newWidth = Math.max(
                        minWidth,
                        resizeRef.current.origWidth + dx,
                    );
                    const newHeight = Math.max(
                        minHeight,
                        resizeRef.current.origHeight + dy,
                    );

                    const availableWidth =
                        window.innerWidth -
                        (widget.x / 100) * window.innerWidth;
                    const availableHeight =
                        window.innerHeight -
                        (widget.y / 100) * window.innerHeight;

                    const clampedWidth = Math.min(
                        newWidth,
                        Math.min(maxWidth, availableWidth),
                    );
                    const clampedHeight = Math.min(
                        newHeight,
                        Math.min(maxHeight, availableHeight),
                    );

                    updateWidgetSize(widget.id, clampedHeight, clampedWidth);
                    updateWidgetRenders();

                    if (e.preventDefault) e.preventDefault();
                }

                function onResizeEnd(e) {
                    document.body.style.userSelect = "";
                    resizeRef.current = {
                        ...resizeRef.current,
                        resizing: false,
                    };
                    window.removeEventListener("mousemove", onResizeMove);
                    window.removeEventListener("mouseup", onResizeEnd);
                    window.removeEventListener("touchmove", onResizeMove);
                    window.removeEventListener("touchend", onResizeEnd);
                    if (e.preventDefault) e.preventDefault();
                }

                function getPointFromEvent(e) {
                    if (e.type && e.type.startsWith("touch")) {
                        const t =
                            e.touches && e.touches[0]
                                ? e.touches[0]
                                : e.changedTouches && e.changedTouches[0]
                                  ? e.changedTouches[0]
                                  : null;
                        return {
                            x: t ? t.clientX : 0,
                            y: t ? t.clientY : 0,
                        };
                    } else {
                        return { x: e.clientX || 0, y: e.clientY || 0 };
                    }
                }

                function onDeleteClick(e) {
                    if (e.preventDefault) e.preventDefault();
                    deleteWidgetInstance(widget.id);
                    updateWidgetRenders();
                }

                function onEditClick(e) {
                    if (e.preventDefault) e.preventDefault();
                    createWindowFromSettings(
                        widget.type,
                        (k) => opts[k],
                        (k, v) => {
                            console.log("Value change:", k, "to", v);
                            setWidgetInstanceOpts(widget.id, {
                                [k]: v,
                            });
                        },
                        widget.id,
                    );
                }

                const WidgetComp = registeredWidgets[widget.type].component;
                if (!WidgetComp) {
                    console.error(
                        `Widget component is undefined for widget:`,
                        widget,
                    );
                    return (
                        <div
                            id={"widget_" + widget.id}
                            className="newtab__widget absolute"
                            style={{
                                left: widget.x + "%",
                                top: widget.y + "%",
                                width: widget.width + "px",
                                height: widget.height + "px",
                            }}
                        >
                            Error: Widget component not found
                        </div>
                    );
                }
                return (
                    <div
                        id={"widget_" + widget.id}
                        className={`newtab__widget absolute ${widget.editMode ? "border-2 border-blue-500/50" : ""}`}
                        style={{
                            left: widget.x + "%",
                            top: widget.y + "%",
                            width: widget.width + "px",
                            height: widget.height + "px",
                        }}
                    >
                        {widget.editMode && (
                            <div className="absolute flex gap-1 top-0 right-1 z-10 bg-black/40 rounded p-1">
                                <div
                                    className="newtab_widget_edit cursor-pointer"
                                    onClick={onEditClick}
                                    title="Settings"
                                    style={{
                                        display: "flex",
                                        alignItems: "center",
                                    }}
                                >
                                    <svg
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="1em"
                                        height="1em"
                                        viewBox="0 0 24 24"
                                    >
                                        <g
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                        >
                                            <path d="M11 10.27L7 3.34m4 10.39l-4 6.93M12 22v-2m0-18v2m2 8h8m-5 8.66l-1-1.73m1-15.59l-1 1.73M2 12h2m16.66 5l-1.73-1m1.73-9l-1.73 1M3.34 17l1.73-1M3.34 7l1.73 1" />
                                            <circle cx="12" cy="12" r="2" />
                                            <circle cx="12" cy="12" r="8" />
                                        </g>
                                    </svg>
                                </div>

                                <div
                                    className="newtab_widget_delete cursor-pointer"
                                    onClick={onDeleteClick}
                                    title="Delete"
                                    style={{
                                        display: "flex",
                                        alignItems: "center",
                                    }}
                                >
                                    <svg
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="1em"
                                        height="1em"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
                                        />
                                    </svg>
                                </div>

                                <div
                                    className="newtab_widget_drag_handle cursor-grab"
                                    onMouseDown={onDragStart}
                                    onTouchStart={onDragStart}
                                    title="Drag"
                                    style={{
                                        display: "flex",
                                        alignItems: "center",
                                    }}
                                >
                                    <svg
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="1em"
                                        height="1em"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2.5"
                                            d="M8 6h.006M8 12h.006M8 18h.006m7.988-12H16m-.006 6H16m-.006 6H16"
                                        />
                                    </svg>
                                </div>
                            </div>
                        )}

                        {widget.editMode && (
                            <div
                                className="absolute bottom-0 right-0 w-4 h-4 bg-blue-500/50 cursor-nw-resize"
                                onMouseDown={onResizeStart}
                                onTouchStart={onResizeStart}
                                title="Resize"
                                style={{
                                    clipPath:
                                        "polygon(100% 0, 0 100%, 100% 100%)",
                                }}
                            />
                        )}

                        <WidgetComp opts={opts} />
                    </div>
                );
            }

            function App() {
                const [editModeState, setEditModeState] = useState(false);
                const [widgetsState, setWidgetsState] = useState(widgets);

                useEffect(() => {
                    rerender_widgets = () => {
                        setWidgetsState([...widgets]);
                    };

                    return () => {
                        rerender_widgets = () => {
                            console.warn("[Newtab] Component unmounted.");
                        };
                    };
                }, []);

                return (
                    <>
                        {widgetsState.map((widget, idx) => (
                            <WidgetWrapper
                                key={[Object.values(widget.opts), idx]}
                                {...widget}
                                editMode={editModeState}
                            />
                        ))}
                        <EditModeToggle editModeSetState={setEditModeState} />
                    </>
                );
            }

            ReactDOM.render(<App />, document.getElementById("root"));
        </script>
    </body>
</html>
