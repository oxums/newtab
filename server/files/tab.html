<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>New tab</title>
        <style>
            ::-webkit-scrollbar {
                width: 12px;
                height: 12px;
                background: transparent;
            }

            ::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, #2563eb 40%, #1e293b 100%);
                border-radius: 8px;
                border: 2px solid #0f172a;
                min-height: 40px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(135deg, #3b82f6 40%, #334155 100%);
            }

            ::-webkit-scrollbar-track {
                background: rgba(30, 41, 59, 0.3);
                border-radius: 8px;
            }

            ::-webkit-scrollbar-corner {
                background: transparent;
            }
            * {
                scrollbar-width: thin;
                scrollbar-color: #2563eb #1e293b;
            }

            option {
                color: black;
            }
        </style>
        <div id="__newtab_scripts"></div>
        <script>
            (function () {
                console.log("[Newtab] Loading scripts...");
                const urls = [
                    "https://unpkg.com/@babel/standalone@7.28.5/babel.min.js",
                    "https://unpkg.com/react@18.3.1/umd/react.production.min.js",
                    "https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js",
                    "https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4",
                ];

                for (let i = 0; i < urls.length; i++) {
                    const key = `res_${urls[i]}`;

                    if (!localStorage.getItem(key)) {
                        console.warn(
                            `[Newtab] Resource not found in localStorage: ${urls[i]}`,
                        );
                        location.href =
                            "/load?reason=load.missing&reason.target=" +
                            encodeURIComponent(urls[i]);
                        return;
                    }

                    const scriptText = localStorage.getItem(key);
                    if (scriptText) {
                        const scriptElem = document.createElement("script");
                        scriptElem.textContent = scriptText;
                        document
                            .getElementById("__newtab_scripts")
                            .appendChild(scriptElem);
                        console.log(
                            `[Newtab] Loaded resource from localStorage: ${urls[i]}`,
                        );
                    } else {
                        console.error(
                            `[Newtab] Empty resource in localStorage: ${urls[i]}`,
                        );
                        location.href =
                            "/load?reason=load.empty&reason.target=" +
                            encodeURIComponent(urls[i]);
                        return;
                    }
                }

                console.log("[Newtab] All scripts loaded successfully.");
            })();
        </script>
    </head>
    <body
        style="background-color: black"
        class="overflow-hidden h-screen w-screen text-white"
    >
        <div id="root"></div>
        <script defer type="text/babel">
            const { useState, useEffect, useRef } = React;

            let isEditMode = false;

            let registeredWidgets = {};

            let rerender_widgets = () => {
                console.warn("[Newtab] Rerender not ready!");
            };

            document.body.removeAttribute("style");

            let bg = localStorage.getItem("prefs_bg") || "";
            let widgets = JSON.parse(
                localStorage.getItem("prefs_widgets") || "[]",
            );

            let isFirstTime = localStorage.getItem("prefs_first_time");
            if (isFirstTime === null) {
                isFirstTime = "true";
            }
            isFirstTime = isFirstTime === "true";

            function pixelsToPercentX(px) {
                return (px / window.innerWidth) * 100;
            }

            function pixelsToPercentY(px) {
                return (px / window.innerHeight) * 100;
            }

            function saveWidgets() {
                console.log(
                    "[Newtab] Saving widgets to localStorage:",
                    widgets,
                );
                localStorage.setItem("prefs_widgets", JSON.stringify(widgets));
            }

            function runPlaceholders(text) {
                if (!text || typeof text !== "string") return text;

                const date = new Date();
                const placeholders = {
                    month: date.getMonth() + 1,
                    day: date.getDate(),
                    year: date.getFullYear(),
                    h: String(date.getHours()).padStart(2, "0"),
                    m: String(date.getMinutes()).padStart(2, "0"),
                    s: String(date.getSeconds()).padStart(2, "0"),
                    "m-": String(date.getMinutes()),
                    "s-": String(date.getSeconds()),
                    "h-": String(date.getHours()),
                    lang: navigator.language || "en-US",
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    origin: location.origin,
                };

                let result = text;
                for (const ph in placeholders) {
                    result = result.replaceAll(
                        "{{" + ph + "}}",
                        placeholders[ph],
                    );
                }
                return result;
            }

            function createWidgetInstance(type, x, y, width, height) {
                console.log(
                    `[Newtab] Creating widget instance: type=${type}, x=${x}, y=${y}, width=${width}, height=${height}`,
                );
                const id = getRandomString();
                const widgetObj = {
                    id,
                    type,
                    x,
                    y,
                    width,
                    height,
                    opts: {},
                };
                widgets.push(widgetObj);
                console.log(
                    `[Newtab] Created widget instance with id: ${id}`,
                    widgetObj,
                );
                saveWidgets();
                return widgetObj;
            }

            function getWidgetInstanceById(id) {
                console.log(`[Newtab] Getting widget instance by id: ${id}`);
                const widget = widgets.find((w) => w.id === id);
                console.log(`[Newtab] Found widget:`, widget);
                return widget;
            }

            function setWidgetInstanceOpts(id, newOpts) {
                console.log(
                    `[Newtab] Setting widget options for id: ${id}`,
                    newOpts,
                );
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const oldOpts = { ...widget.opts };
                    widget.opts = { ...widget.opts, ...newOpts };
                    console.log(
                        `[Newtab] Updated widget options for id: ${id}`,
                        { oldOpts, newOpts: widget.opts },
                    );
                    saveWidgets();
                    updateWidgetRenders();
                } else {
                    console.warn(
                        `[Newtab] Widget not found for setWidgetInstanceOpts: ${id}`,
                    );
                }
            }

            function updateWidgetPosition(id, x, y) {
                console.log(
                    `[Newtab] Updating widget position for id: ${id}, x=${x}, y=${y}`,
                );
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const oldPosition = { x: widget.x, y: widget.y };
                    widget.x = x;
                    widget.y = y;
                    console.log(
                        `[Newtab] Updated widget position for id: ${id}`,
                        { oldPosition, newPosition: { x, y } },
                    );
                    saveWidgets();
                } else {
                    console.warn(
                        `[Newtab] Widget not found for updateWidgetPosition: ${id}`,
                    );
                }
            }

            function getWidgetInstanceOpts(id) {
                console.log(`[Newtab] Getting widget options for id: ${id}`);
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const opts = widget.opts || {};
                    console.log(
                        `[Newtab] Retrieved widget options for id: ${id}`,
                        opts,
                    );
                    return opts;
                }
                console.warn(
                    `[Newtab] Widget not found for getWidgetInstanceOpts: ${id}`,
                );
                return {};
            }

            function deleteWidgetInstance(id) {
                console.log(`[Newtab] Deleting widget instance with id: ${id}`);
                const initialCount = widgets.length;
                widgets = widgets.filter((w) => w.id !== id);
                const deletedCount = initialCount - widgets.length;
                console.log(
                    `[Newtab] Deleted ${deletedCount} widget(s) with id: ${id}. Remaining widgets:`,
                    widgets.length,
                );
                saveWidgets();
            }

            function updateWidgetRenders() {
                console.log("[Newtab] Updating widget renders...");
                rerender_widgets();
            }

            function getRandomString() {
                return (
                    Math.random().toString(36).substring(2, 10) +
                    Math.random().toString(36).substring(2, 10)
                );
            }

            function updateWidgetSize(id, h, w) {
                console.log(
                    `[Newtab] Updating widget size for id: ${id}, width=${w}, height=${h}`,
                );
                const widget = getWidgetInstanceById(id);
                if (widget) {
                    const oldSize = {
                        width: widget.width,
                        height: widget.height,
                    };
                    widget.width = w;
                    widget.height = h;
                    console.log(`[Newtab] Updated widget size for id: ${id}`, {
                        oldSize,
                        newSize: { width: w, height: h },
                    });
                    saveWidgets();
                    updateWidgetRenders();
                } else {
                    console.warn(
                        `[Newtab] Widget not found for updateWidgetSize: ${id}`,
                    );
                }
            }

            if (!bg) {
                bg = JSON.stringify({
                    type: "solidcolor",
                    color: "#000",
                });
                localStorage.setItem("prefs_bg", bg);
            }

            function bg_to_css(bg_object) {
                if (bg_object.type === "solidcolor") {
                    return bg_object.color;
                } else if (bg_object.type === "gradient") {
                    return `linear-gradient(in oklch ${bg_object.angle}deg, ${bg_object.colors.join(", ")})`;
                } else if (bg_object.type === "image") {
                    return `url(${bg_object.url}) center/cover no-repeat`;
                } else {
                    return "#000";
                }
            }

            document.body.style.background = bg_to_css(JSON.parse(bg));

            function registerWidget(
                id,
                displayName,
                component,
                resizeBounds,
                initialSize,
                settings,
            ) {
                registeredWidgets[id] = {
                    displayName,
                    component,
                    resizeBounds,
                    initialSize,
                    settings,
                };
            }

            function hexToRgba(hex, opacity) {
                hex = hex.replace(/^#/, "");
                let r = 0,
                    g = 0,
                    b = 0;
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else if (hex.length === 6) {
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                }
                return `rgba(${r},${g},${b},${opacity})`;
            }

            function parseCustomCss(cssString) {
                if (!cssString) return {};
                const styleObj = {};
                cssString.split(";").forEach((rule) => {
                    const [prop, value] = rule.split(":");
                    if (prop && value) {
                        styleObj[prop.trim()] = value.trim();
                    }
                });
                return styleObj;
            }

            registerWidget(
                "text",
                "Text",
                ({ opts }) => {
                    const style = {
                        fontSize: (opts.fontSize || 16) + "px",
                        color: opts.color || "#ffffff",
                        fontFamily: opts.font || "Arial, sans-serif",
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        textAlign: "center",
                        boxSizing: "border-box",
                        borderRadius: opts.borderRadius
                            ? opts.borderRadius + "px"
                            : "0px",
                        backdropFilter: opts.backgroundBlur
                            ? `blur(${opts.backgroundBlur}px)`
                            : undefined,
                        filter: opts.blur ? `blur(${opts.blur}px)` : undefined,
                        backgroundColor: opts.backgroundColor
                            ? opts.backgroundColor
                            : undefined,
                        background:
                            opts.backgroundColor &&
                            opts.backgroundOpacity !== undefined
                                ? hexToRgba(
                                      opts.backgroundColor,
                                      opts.backgroundOpacity / 100,
                                  )
                                : opts.backgroundColor
                                  ? opts.backgroundColor
                                  : undefined,
                        opacity:
                            opts.textOpacity !== undefined
                                ? opts.textOpacity / 100
                                : 1,
                        ...(opts.customCss
                            ? parseCustomCss(opts.customCss)
                            : {}),
                    };

                    return (
                        <div style={style}>
                            {runPlaceholders(opts.text) || "Hello, world!"}
                        </div>
                    );
                },
                [
                    [600, 600],
                    [50, 50],
                ],
                [150, 60],
                {
                    text: {
                        type: "string",
                        label: "Text",
                        default: "Hello, world!",
                        placeholders: true,
                    },
                    fontSize: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Font Size",
                        default: 16,
                        min: 8,
                        max: 72,
                    },
                    color: {
                        type: "color",
                        label: "Color",
                        default: "#ffffff",
                    },
                    font: {
                        type: "font",
                        label: "Font",
                        default: "Arial",
                    },
                    blur: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Text Blur (px)",
                        default: 0,
                        min: 0,
                        max: 20,
                    },
                    backgroundBlur: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Background Blur (px)",
                        default: 0,
                        min: 0,
                        max: 40,
                    },
                    backgroundColor: {
                        type: "color",
                        label: "Background Color",
                        default: "",
                    },
                    backgroundOpacity: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Background Opacity",
                        default: 100,
                        min: 0,
                        max: 100,
                    },
                    textOpacity: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Opacity",
                        default: 100,
                        min: 0,
                        max: 100,
                    },
                    borderRadius: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Border Radius (px)",
                        default: 0,
                        min: 0,
                        max: 200,
                    },
                    customCss: {
                        type: "string",
                        label: "Custom CSS (inline)",
                        default: "",
                        typeRefine: "multiline",
                    },
                },
            );

            registerWidget(
                "clock",
                "Clock",
                ({ opts }) => {
                    const style = {
                        fontSize: (opts.fontSize || 16) + "px",
                        color: opts.color || "#ffffff",
                        fontFamily: opts.font || "Arial, sans-serif",
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        textAlign: "center",
                        boxSizing: "border-box",
                        borderRadius: opts.borderRadius
                            ? opts.borderRadius + "px"
                            : "0px",
                        backdropFilter: opts.backgroundBlur
                            ? `blur(${opts.backgroundBlur}px)`
                            : undefined,
                        filter: opts.blur ? `blur(${opts.blur}px)` : undefined,
                        backgroundColor: opts.backgroundColor
                            ? opts.backgroundColor
                            : undefined,
                        background:
                            opts.backgroundColor &&
                            opts.backgroundOpacity !== undefined
                                ? hexToRgba(
                                      opts.backgroundColor,
                                      opts.backgroundOpacity / 100,
                                  )
                                : opts.backgroundColor
                                  ? opts.backgroundColor
                                  : undefined,
                        opacity:
                            opts.textOpacity !== undefined
                                ? opts.textOpacity / 100
                                : 1,
                        ...(opts.customCss
                            ? parseCustomCss(opts.customCss)
                            : {}),
                    };

                    const [now, setNow] = useState(new Date());

                    useEffect(() => {
                        const interval = setInterval(() => {
                            setNow(new Date());
                        }, 1000);
                        return () => clearInterval(interval);
                    }, []);

                    function formatClock(date, template, use12Hour, timezone) {
                        let d = date;
                        if (timezone && timezone !== "local") {
                            const options = {
                                hour: "2-digit",
                                minute: "2-digit",
                                second: "2-digit",
                                hour12: false,
                                timeZone: timezone,
                                year: "numeric",
                                month: "2-digit",
                                day: "2-digit",
                            };
                            
                            const parts = new Intl.DateTimeFormat("en-US", options).formatToParts(date);
                            let h = 0, m = 0, s = 0, year = 0, month = 0, day = 0;
                            for (const part of parts) {
                                if (part.type === "hour") h = parseInt(part.value, 10);
                                if (part.type === "minute") m = parseInt(part.value, 10);
                                if (part.type === "second") s = parseInt(part.value, 10);
                                if (part.type === "year") year = parseInt(part.value, 10);
                                if (part.type === "month") month = parseInt(part.value, 10);
                                if (part.type === "day") day = parseInt(part.value, 10);
                            }
                            d = { h, m, s, year, month, day };
                        } else {
                            d = {
                                h: date.getHours(),
                                m: date.getMinutes(),
                                s: date.getSeconds(),
                                year: date.getFullYear(),
                                month: date.getMonth() + 1,
                                day: date.getDate(),
                            };
                        }

                        let h = d.h;
                        let m = d.m;
                        let s = d.s;
                        let ampm = "";
                        if (use12Hour) {
                            ampm = h >= 12 ? "PM" : "AM";
                            h = h % 12;
                            if (h === 0) h = 12;
                        }
                        const pad = (n) => String(n).padStart(2, "0");
                        let str = template || "{h}:{m}:{s}";
                        str = str.replaceAll("{h}", pad(h));
                        str = str.replaceAll("{m}", pad(m));
                        str = str.replaceAll("{s}", pad(s));
                        str = str.replaceAll("{ampm}", ampm);
                        str = str.replaceAll("{year}", d.year);
                        str = str.replaceAll("{month}", pad(d.month));
                        str = str.replaceAll("{day}", pad(d.day));
                        return str;
                    }

                    return (
                        <div style={style}>
                            {formatClock(
                                now,
                                opts.template || "{h}:{m}:{s} {ampm}",
                                opts.format !== undefined ? opts.format : true,
                                opts.timezone || "local",
                            )}
                        </div>
                    );
                },
                [
                    [600, 600],
                    [50, 50],
                ],
                [150, 60],
                {
                    template: {
                        type: "string",
                        label: "Format",
                        default: "{h}:{m}:{s} {ampm}",
                    },
                    format: {
                        type: "boolean",
                        label: "12-hour format",
                        default: true,
                    },
                    timezone: {
                        type: "option",
                        label: "Timezone",
                        default: "local",
                        options: [
                            { value: "local", label: "Local" },
                            { value: "UTC", label: "UTC" },
                            {
                                value: "America/New_York",
                                label: "New York (EST)",
                            },
                            {
                                value: "America/Chicago",
                                label: "Chicago (CST)",
                            },
                            { value: "America/Denver", label: "Denver (MST)" },
                            {
                                value: "America/Los_Angeles",
                                label: "Los Angeles (PST)",
                            },
                            { value: "Europe/London", label: "London (GMT)" },
                            { value: "Europe/Paris", label: "Paris (CET)" },
                            { value: "Asia/Tokyo", label: "Tokyo (JST)" },
                            { value: "Asia/Shanghai", label: "Shanghai (CST)" },
                            {
                                value: "Australia/Sydney",
                                label: "Sydney (AEST)",
                            },
                            { value: "Europe/Berlin", label: "Berlin (CET)" },
                            { value: "Europe/Moscow", label: "Moscow (MSK)" },
                            { value: "Asia/Kolkata", label: "India (IST)" },
                            {
                                value: "Asia/Hong_Kong",
                                label: "Hong Kong (HKT)",
                            },
                            {
                                value: "Asia/Singapore",
                                label: "Singapore (SGT)",
                            },
                            { value: "Asia/Dubai", label: "Dubai (GST)" },
                            { value: "Asia/Jakarta", label: "Jakarta (WIB)" },
                            { value: "Asia/Seoul", label: "Seoul (KST)" },
                            {
                                value: "Pacific/Auckland",
                                label: "Auckland (NZST)",
                            },
                            {
                                value: "Pacific/Honolulu",
                                label: "Honolulu (HST)",
                            },
                            {
                                value: "America/Sao_Paulo",
                                label: "São Paulo (BRT)",
                            },
                            {
                                value: "America/Mexico_City",
                                label: "Mexico City (CST)",
                            },
                            {
                                value: "Africa/Johannesburg",
                                label: "Johannesburg (SAST)",
                            },
                            { value: "Africa/Cairo", label: "Cairo (EET)" },
                            {
                                value: "Europe/Istanbul",
                                label: "Istanbul (TRT)",
                            },
                            { value: "Europe/Madrid", label: "Madrid (CET)" },
                            { value: "Europe/Rome", label: "Rome (CET)" },
                            {
                                value: "Europe/Amsterdam",
                                label: "Amsterdam (CET)",
                            },
                            { value: "Europe/Zurich", label: "Zurich (CET)" },
                            {
                                value: "Europe/Brussels",
                                label: "Brussels (CET)",
                            },
                            {
                                value: "Europe/Stockholm",
                                label: "Stockholm (CET)",
                            },
                            { value: "Europe/Warsaw", label: "Warsaw (CET)" },
                            { value: "Europe/Athens", label: "Athens (EET)" },
                            {
                                value: "Europe/Bucharest",
                                label: "Bucharest (EET)",
                            },
                            {
                                value: "Europe/Helsinki",
                                label: "Helsinki (EET)",
                            },
                            { value: "Europe/Kiev", label: "Kyiv (EET)" },
                            { value: "Europe/Prague", label: "Prague (CET)" },
                            { value: "Europe/Vienna", label: "Vienna (CET)" },
                            {
                                value: "Europe/Budapest",
                                label: "Budapest (CET)",
                            },
                            { value: "Europe/Lisbon", label: "Lisbon (WET)" },
                            { value: "Europe/Dublin", label: "Dublin (GMT)" },
                            { value: "Europe/Oslo", label: "Oslo (CET)" },
                            {
                                value: "Europe/Copenhagen",
                                label: "Copenhagen (CET)",
                            },
                            {
                                value: "Europe/Belgrade",
                                label: "Belgrade (CET)",
                            },
                            { value: "Europe/Sofia", label: "Sofia (EET)" },
                            { value: "Europe/Tallinn", label: "Tallinn (EET)" },
                            { value: "Europe/Riga", label: "Riga (EET)" },
                            { value: "Europe/Vilnius", label: "Vilnius (EET)" },
                            {
                                value: "Europe/Luxembourg",
                                label: "Luxembourg (CET)",
                            },
                            { value: "Europe/Monaco", label: "Monaco (CET)" },
                            { value: "Europe/Andorra", label: "Andorra (CET)" },
                            {
                                value: "Europe/Sarajevo",
                                label: "Sarajevo (CET)",
                            },
                            {
                                value: "Europe/Podgorica",
                                label: "Podgorica (CET)",
                            },
                            { value: "Europe/Skopje", label: "Skopje (CET)" },
                            { value: "Europe/Zagreb", label: "Zagreb (CET)" },
                            {
                                value: "Europe/Ljubljana",
                                label: "Ljubljana (CET)",
                            },
                            { value: "Europe/Tirane", label: "Tirana (CET)" },
                            { value: "Europe/Minsk", label: "Minsk (MSK)" },
                            {
                                value: "Europe/Chisinau",
                                label: "Chisinau (EET)",
                            },
                            {
                                value: "Europe/Bratislava",
                                label: "Bratislava (CET)",
                            },
                            { value: "Europe/Samara", label: "Samara (SAMT)" },
                            {
                                value: "Europe/Kaliningrad",
                                label: "Kaliningrad (EET)",
                            },
                            {
                                value: "Europe/Uzhgorod",
                                label: "Uzhgorod (EET)",
                            },
                            {
                                value: "Europe/Zaporozhye",
                                label: "Zaporizhzhia (EET)",
                            },
                            {
                                value: "Europe/Volgograd",
                                label: "Volgograd (MSK)",
                            },
                            {
                                value: "America/Anchorage",
                                label: "Anchorage (AKST)",
                            },
                            {
                                value: "America/Phoenix",
                                label: "Phoenix (MST)",
                            },
                            {
                                value: "America/Argentina/Buenos_Aires",
                                label: "Buenos Aires (ART)",
                            },
                            { value: "America/Bogota", label: "Bogotá (COT)" },
                            { value: "America/Lima", label: "Lima (PET)" },
                            {
                                value: "America/Santiago",
                                label: "Santiago (CLT)",
                            },
                            {
                                value: "America/Caracas",
                                label: "Caracas (VET)",
                            },
                            {
                                value: "America/Guatemala",
                                label: "Guatemala (CST)",
                            },
                            { value: "America/Panama", label: "Panama (EST)" },
                            { value: "America/Havana", label: "Havana (CST)" },
                            {
                                value: "America/Montevideo",
                                label: "Montevideo (UYT)",
                            },
                            { value: "America/La_Paz", label: "La Paz (BOT)" },
                            {
                                value: "America/Asuncion",
                                label: "Asunción (PYT)",
                            },
                            {
                                value: "America/Managua",
                                label: "Managua (CST)",
                            },
                            {
                                value: "America/San_Jose",
                                label: "San José (CST)",
                            },
                            {
                                value: "America/Tegucigalpa",
                                label: "Tegucigalpa (CST)",
                            },
                            {
                                value: "America/El_Salvador",
                                label: "San Salvador (CST)",
                            },
                            { value: "America/Belize", label: "Belize (CST)" },
                            {
                                value: "America/Jamaica",
                                label: "Jamaica (EST)",
                            },
                            {
                                value: "America/Barbados",
                                label: "Barbados (AST)",
                            },
                            {
                                value: "America/Port_of_Spain",
                                label: "Port of Spain (AST)",
                            },
                            {
                                value: "America/Halifax",
                                label: "Halifax (AST)",
                            },
                            {
                                value: "America/St_Johns",
                                label: "St. John's (NST)",
                            },
                            {
                                value: "America/Vancouver",
                                label: "Vancouver (PST)",
                            },
                            {
                                value: "America/Toronto",
                                label: "Toronto (EST)",
                            },
                            {
                                value: "America/Edmonton",
                                label: "Edmonton (MST)",
                            },
                            {
                                value: "America/Winnipeg",
                                label: "Winnipeg (CST)",
                            },
                            { value: "America/Regina", label: "Regina (CST)" },
                            {
                                value: "America/Whitehorse",
                                label: "Whitehorse (PST)",
                            },
                            {
                                value: "America/Yellowknife",
                                label: "Yellowknife (MST)",
                            },
                            {
                                value: "America/Iqaluit",
                                label: "Iqaluit (EST)",
                            },
                            {
                                value: "America/Goose_Bay",
                                label: "Goose Bay (AST)",
                            },
                            {
                                value: "America/Rankin_Inlet",
                                label: "Rankin Inlet (CST)",
                            },
                            {
                                value: "America/Resolute",
                                label: "Resolute (CST)",
                            },
                            {
                                value: "America/Atikokan",
                                label: "Atikokan (EST)",
                            },
                            {
                                value: "America/Blanc-Sablon",
                                label: "Blanc-Sablon (AST)",
                            },
                            {
                                value: "America/Cambridge_Bay",
                                label: "Cambridge Bay (MST)",
                            },
                            {
                                value: "America/Creston",
                                label: "Creston (MST)",
                            },
                            { value: "America/Dawson", label: "Dawson (PST)" },
                            {
                                value: "America/Fort_Nelson",
                                label: "Fort Nelson (MST)",
                            },
                            {
                                value: "America/Swift_Current",
                                label: "Swift Current (CST)",
                            },
                            {
                                value: "America/Glace_Bay",
                                label: "Glace Bay (AST)",
                            },
                            {
                                value: "America/Moncton",
                                label: "Moncton (AST)",
                            },
                            {
                                value: "America/Thunder_Bay",
                                label: "Thunder Bay (EST)",
                            },
                            { value: "America/Nassau", label: "Nassau (EST)" },
                            {
                                value: "America/Hermosillo",
                                label: "Hermosillo (MST)",
                            },
                            {
                                value: "America/Tijuana",
                                label: "Tijuana (PST)",
                            },
                            {
                                value: "America/Mazatlan",
                                label: "Mazatlán (MST)",
                            },
                            { value: "America/Cancun", label: "Cancún (EST)" },
                            { value: "America/Merida", label: "Mérida (CST)" },
                            {
                                value: "America/Chihuahua",
                                label: "Chihuahua (MST)",
                            },
                            {
                                value: "America/Ojinaga",
                                label: "Ojinaga (MST)",
                            },
                            {
                                value: "America/Matamoros",
                                label: "Matamoros (CST)",
                            },
                            {
                                value: "America/Monterrey",
                                label: "Monterrey (CST)",
                            },
                            {
                                value: "America/Bahia_Banderas",
                                label: "Bahía de Banderas (CST)",
                            },
                            {
                                value: "America/Culiacan",
                                label: "Culiacán (MST)",
                            },
                            {
                                value: "America/Ensenada",
                                label: "Ensenada (PST)",
                            },
                            {
                                value: "America/Guadalajara",
                                label: "Guadalajara (CST)",
                            },
                            {
                                value: "America/Mexico_City",
                                label: "Mexico City (CST)",
                            },
                            {
                                value: "America/Tegucigalpa",
                                label: "Tegucigalpa (CST)",
                            },
                            {
                                value: "America/Managua",
                                label: "Managua (CST)",
                            },
                            { value: "America/Panama", label: "Panama (EST)" },
                            { value: "America/Bogota", label: "Bogotá (COT)" },
                            { value: "America/Lima", label: "Lima (PET)" },
                            {
                                value: "America/Caracas",
                                label: "Caracas (VET)",
                            },
                            {
                                value: "America/Santiago",
                                label: "Santiago (CLT)",
                            },
                            { value: "America/La_Paz", label: "La Paz (BOT)" },
                            {
                                value: "America/Asuncion",
                                label: "Asunción (PYT)",
                            },
                            {
                                value: "America/Montevideo",
                                label: "Montevideo (UYT)",
                            },
                            {
                                value: "America/Argentina/Buenos_Aires",
                                label: "Buenos Aires (ART)",
                            },
                            {
                                value: "America/Sao_Paulo",
                                label: "São Paulo (BRT)",
                            },
                            { value: "Pacific/Fiji", label: "Fiji (FJT)" },
                            { value: "Pacific/Guam", label: "Guam (ChST)" },
                            {
                                value: "Pacific/Port_Moresby",
                                label: "Port Moresby (PGT)",
                            },
                            {
                                value: "Pacific/Tongatapu",
                                label: "Nukuʻalofa (TOT)",
                            },
                            { value: "Pacific/Apia", label: "Apia (WSST)" },
                            { value: "Pacific/Noumea", label: "Nouméa (NCT)" },
                            {
                                value: "Pacific/Pago_Pago",
                                label: "Pago Pago (SST)",
                            },
                            { value: "Pacific/Majuro", label: "Majuro (MHT)" },
                            { value: "Pacific/Palau", label: "Palau (PWT)" },
                            { value: "Pacific/Saipan", label: "Saipan (ChST)" },
                            { value: "Pacific/Tarawa", label: "Tarawa (GILT)" },
                            {
                                value: "Pacific/Funafuti",
                                label: "Funafuti (TVT)",
                            },
                            { value: "Pacific/Nauru", label: "Nauru (NRT)" },
                            { value: "Pacific/Niue", label: "Alofi (NUT)" },
                            {
                                value: "Pacific/Rarotonga",
                                label: "Rarotonga (CKT)",
                            },
                            {
                                value: "Pacific/Wake",
                                label: "Wake Island (WAKT)",
                            },
                            { value: "Pacific/Wallis", label: "Wallis (WFT)" },
                            { value: "Africa/Abidjan", label: "Abidjan (GMT)" },
                            { value: "Africa/Accra", label: "Accra (GMT)" },
                            {
                                value: "Africa/Addis_Ababa",
                                label: "Addis Ababa (EAT)",
                            },
                            { value: "Africa/Algiers", label: "Algiers (CET)" },
                            { value: "Africa/Asmara", label: "Asmara (EAT)" },
                            { value: "Africa/Bamako", label: "Bamako (GMT)" },
                            { value: "Africa/Bangui", label: "Bangui (WAT)" },
                            { value: "Africa/Banjul", label: "Banjul (GMT)" },
                            { value: "Africa/Bissau", label: "Bissau (GMT)" },
                            {
                                value: "Africa/Blantyre",
                                label: "Blantyre (CAT)",
                            },
                            {
                                value: "Africa/Brazzaville",
                                label: "Brazzaville (WAT)",
                            },
                            {
                                value: "Africa/Bujumbura",
                                label: "Bujumbura (CAT)",
                            },
                            { value: "Africa/Cairo", label: "Cairo (EET)" },
                            {
                                value: "Africa/Casablanca",
                                label: "Casablanca (WET)",
                            },
                            { value: "Africa/Ceuta", label: "Ceuta (CET)" },
                            { value: "Africa/Conakry", label: "Conakry (GMT)" },
                            { value: "Africa/Dakar", label: "Dakar (GMT)" },
                            {
                                value: "Africa/Dar_es_Salaam",
                                label: "Dar es Salaam (EAT)",
                            },
                            {
                                value: "Africa/Djibouti",
                                label: "Djibouti (EAT)",
                            },
                            { value: "Africa/Douala", label: "Douala (WAT)" },
                            {
                                value: "Africa/El_Aaiun",
                                label: "El Aaiún (WET)",
                            },
                            {
                                value: "Africa/Freetown",
                                label: "Freetown (GMT)",
                            },
                            {
                                value: "Africa/Gaborone",
                                label: "Gaborone (CAT)",
                            },
                            { value: "Africa/Harare", label: "Harare (CAT)" },
                            {
                                value: "Africa/Johannesburg",
                                label: "Johannesburg (SAST)",
                            },
                            { value: "Africa/Juba", label: "Juba (CAT)" },
                            { value: "Africa/Kampala", label: "Kampala (EAT)" },
                            {
                                value: "Africa/Khartoum",
                                label: "Khartoum (CAT)",
                            },
                            { value: "Africa/Kigali", label: "Kigali (CAT)" },
                            {
                                value: "Africa/Kinshasa",
                                label: "Kinshasa (WAT)",
                            },
                            { value: "Africa/Lagos", label: "Lagos (WAT)" },
                            {
                                value: "Africa/Libreville",
                                label: "Libreville (WAT)",
                            },
                            { value: "Africa/Lome", label: "Lomé (GMT)" },
                            { value: "Africa/Luanda", label: "Luanda (WAT)" },
                            {
                                value: "Africa/Lubumbashi",
                                label: "Lubumbashi (CAT)",
                            },
                            { value: "Africa/Lusaka", label: "Lusaka (CAT)" },
                            { value: "Africa/Malabo", label: "Malabo (WAT)" },
                            { value: "Africa/Maputo", label: "Maputo (CAT)" },
                            { value: "Africa/Maseru", label: "Maseru (SAST)" },
                            {
                                value: "Africa/Mbabane",
                                label: "Mbabane (SAST)",
                            },
                            {
                                value: "Africa/Mogadishu",
                                label: "Mogadishu (EAT)",
                            },
                            {
                                value: "Africa/Monrovia",
                                label: "Monrovia (GMT)",
                            },
                            { value: "Africa/Nairobi", label: "Nairobi (EAT)" },
                            {
                                value: "Africa/Ndjamena",
                                label: "N'Djamena (WAT)",
                            },
                            { value: "Africa/Niamey", label: "Niamey (WAT)" },
                            {
                                value: "Africa/Nouakchott",
                                label: "Nouakchott (GMT)",
                            },
                            {
                                value: "Africa/Ouagadougou",
                                label: "Ouagadougou (GMT)",
                            },
                            {
                                value: "Africa/Porto-Novo",
                                label: "Porto-Novo (WAT)",
                            },
                            {
                                value: "Africa/Sao_Tome",
                                label: "São Tomé (GMT)",
                            },
                            { value: "Africa/Tripoli", label: "Tripoli (EET)" },
                            { value: "Africa/Tunis", label: "Tunis (CET)" },
                            {
                                value: "Africa/Windhoek",
                                label: "Windhoek (CAT)",
                            },
                            { value: "Asia/Baghdad", label: "Baghdad (AST)" },
                            { value: "Asia/Bahrain", label: "Bahrain (AST)" },
                            { value: "Asia/Baku", label: "Baku (AZT)" },
                            { value: "Asia/Bangkok", label: "Bangkok (ICT)" },
                            { value: "Asia/Beirut", label: "Beirut (EET)" },
                            { value: "Asia/Damascus", label: "Damascus (EET)" },
                            { value: "Asia/Gaza", label: "Gaza (EET)" },
                            { value: "Asia/Hebron", label: "Hebron (EET)" },
                            {
                                value: "Asia/Jerusalem",
                                label: "Jerusalem (IST)",
                            },
                            { value: "Asia/Karachi", label: "Karachi (PKT)" },
                            {
                                value: "Asia/Kathmandu",
                                label: "Kathmandu (NPT)",
                            },
                            { value: "Asia/Kuwait", label: "Kuwait (AST)" },
                            { value: "Asia/Muscat", label: "Muscat (GST)" },
                            { value: "Asia/Qatar", label: "Doha (AST)" },
                            { value: "Asia/Riyadh", label: "Riyadh (AST)" },
                            { value: "Asia/Taipei", label: "Taipei (CST)" },
                            { value: "Asia/Tehran", label: "Tehran (IRST)" },
                            { value: "Asia/Thimphu", label: "Thimphu (BTT)" },
                            {
                                value: "Asia/Ulaanbaatar",
                                label: "Ulaanbaatar (ULAT)",
                            },
                            {
                                value: "Asia/Vientiane",
                                label: "Vientiane (ICT)",
                            },
                            { value: "Asia/Yangon", label: "Yangon (MMT)" },
                            {
                                value: "Asia/Yekaterinburg",
                                label: "Yekaterinburg (YEKT)",
                            },
                            {
                                value: "Asia/Novosibirsk",
                                label: "Novosibirsk (NOVT)",
                            },
                            { value: "Asia/Irkutsk", label: "Irkutsk (IRKT)" },
                            {
                                value: "Asia/Krasnoyarsk",
                                label: "Krasnoyarsk (KRAT)",
                            },
                            {
                                value: "Asia/Vladivostok",
                                label: "Vladivostok (VLAT)",
                            },
                            { value: "Asia/Magadan", label: "Magadan (MAGT)" },
                            {
                                value: "Asia/Kamchatka",
                                label: "Petropavlovsk-Kamchatsky (PETT)",
                            },
                            {
                                value: "Asia/Sakhalin",
                                label: "Yuzhno-Sakhalinsk (SAKT)",
                            },
                            { value: "Asia/Chita", label: "Chita (YAKT)" },
                            { value: "Asia/Yakutsk", label: "Yakutsk (YAKT)" },
                            { value: "Asia/Omsk", label: "Omsk (OMST)" },
                            { value: "Asia/Tomsk", label: "Tomsk (KRAT)" },
                            { value: "Asia/Barnaul", label: "Barnaul (KRAT)" },
                            {
                                value: "Asia/Khandyga",
                                label: "Khandyga (YAKT)",
                            },
                            {
                                value: "Asia/Ust-Nera",
                                label: "Ust-Nera (VLAT)",
                            },
                            { value: "Asia/Anadyr", label: "Anadyr (ANAT)" },
                            {
                                value: "Australia/Adelaide",
                                label: "Adelaide (ACST)",
                            },
                            {
                                value: "Australia/Brisbane",
                                label: "Brisbane (AEST)",
                            },
                            {
                                value: "Australia/Darwin",
                                label: "Darwin (ACST)",
                            },
                            {
                                value: "Australia/Hobart",
                                label: "Hobart (AEST)",
                            },
                            {
                                value: "Australia/Melbourne",
                                label: "Melbourne (AEST)",
                            },
                            { value: "Australia/Perth", label: "Perth (AWST)" },
                            {
                                value: "Australia/Sydney",
                                label: "Sydney (AEST)",
                            },
                            {
                                value: "Australia/Broken_Hill",
                                label: "Broken Hill (ACST)",
                            },
                            {
                                value: "Australia/Lord_Howe",
                                label: "Lord Howe Island (LHST)",
                            },
                            {
                                value: "Antarctica/Casey",
                                label: "Casey (AWST)",
                            },
                            {
                                value: "Antarctica/Davis",
                                label: "Davis (DAVT)",
                            },
                            {
                                value: "Antarctica/DumontDUrville",
                                label: "Dumont d'Urville (DDUT)",
                            },
                            {
                                value: "Antarctica/Macquarie",
                                label: "Macquarie Island (MIST)",
                            },
                            {
                                value: "Antarctica/Mawson",
                                label: "Mawson (MAWT)",
                            },
                            {
                                value: "Antarctica/Palmer",
                                label: "Palmer (CLT)",
                            },
                            {
                                value: "Antarctica/Rothera",
                                label: "Rothera (ROTT)",
                            },
                            {
                                value: "Antarctica/Syowa",
                                label: "Syowa (SYOT)",
                            },
                            {
                                value: "Antarctica/Troll",
                                label: "Troll (UTC+2)",
                            },
                            {
                                value: "Antarctica/Vostok",
                                label: "Vostok (VOST)",
                            },
                        ],
                    },
                    fontSize: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Font Size",
                        default: 16,
                        min: 8,
                        max: 72,
                    },
                    color: {
                        type: "color",
                        label: "Color",
                        default: "#ffffff",
                    },
                    font: {
                        type: "font",
                        label: "Font",
                        default: "Arial",
                    },
                    blur: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Text Blur (px)",
                        default: 0,
                        min: 0,
                        max: 20,
                    },
                    backgroundBlur: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Background Blur (px)",
                        default: 0,
                        min: 0,
                        max: 40,
                    },
                    backgroundColor: {
                        type: "color",
                        label: "Background Color",
                        default: "",
                    },
                    backgroundOpacity: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Background Opacity",
                        default: 100,
                        min: 0,
                        max: 100,
                    },
                    textOpacity: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Opacity",
                        default: 100,
                        min: 0,
                        max: 100,
                    },
                    borderRadius: {
                        type: "number",
                        typeRefine: "slider",
                        label: "Border Radius (px)",
                        default: 0,
                        min: 0,
                        max: 200,
                    },
                    customCss: {
                        type: "string",
                        label: "Custom CSS (inline)",
                        default: "",
                        typeRefine: "multiline",
                    },
                },
            );

            function EditWindow({
                title,
                icon,
                content,
                onClose,
                onFocus,
                scrollable,
            }) {
                const [pos, setPos] = useState({
                    x: 100 + Math.floor(Math.random() * 500),
                    y: 100 + Math.floor(Math.random() * 200),
                });
                const windowRef = useRef(null);
                const draggingRef = useRef(false);
                const startRef = useRef({ x: 0, y: 0, origX: 0, origY: 0 });

                useEffect(() => {
                    function onMove(e) {
                        if (!draggingRef.current) return;
                        let clientX, clientY;
                        if (e.type.startsWith("touch")) {
                            const t = e.touches[0] || e.changedTouches[0];
                            clientX = t.clientX;
                            clientY = t.clientY;
                        } else {
                            clientX = e.clientX;
                            clientY = e.clientY;
                        }
                        const dx = clientX - startRef.current.x;
                        const dy = clientY - startRef.current.y;
                        setPos({
                            x: startRef.current.origX + dx,
                            y: startRef.current.origY + dy,
                        });
                        if (e.preventDefault) e.preventDefault();
                    }

                    function onUp() {
                        if (!draggingRef.current) return;
                        draggingRef.current = false;
                        document.body.style.userSelect = "";
                        window.removeEventListener("mousemove", onMove);
                        window.removeEventListener("mouseup", onUp);
                        window.removeEventListener("touchmove", onMove);
                        window.removeEventListener("touchend", onUp);
                    }

                    window.addEventListener("mousemove", onMove);
                    window.addEventListener("mouseup", onUp);
                    window.addEventListener("touchmove", onMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onUp);

                    return () => {
                        draggingRef.current = false;
                        window.removeEventListener("mousemove", onMove);
                        window.removeEventListener("mouseup", onUp);
                        window.removeEventListener("touchmove", onMove);
                        window.removeEventListener("touchend", onUp);
                    };
                }, []);

                function startDrag(e) {
                    if (e.button === 2) return;
                    let clientX, clientY;
                    if (e.type === "touchstart") {
                        const t = e.touches[0];
                        clientX = t.clientX;
                        clientY = t.clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    draggingRef.current = true;
                    startRef.current = {
                        x: clientX,
                        y: clientY,
                        origX: pos.x,
                        origY: pos.y,
                    };

                    document.body.style.userSelect = "none";

                    function onMove(e) {
                        if (!draggingRef.current) return;
                        let mX, mY;
                        if (e.type.startsWith("touch")) {
                            const t = e.touches[0] || e.changedTouches[0];
                            mX = t.clientX;
                            mY = t.clientY;
                        } else {
                            mX = e.clientX;
                            mY = e.clientY;
                        }
                        const dx = mX - startRef.current.x;
                        const dy = mY - startRef.current.y;
                        setPos({
                            x: startRef.current.origX + dx,
                            y: startRef.current.origY + dy,
                        });
                        if (e.preventDefault) e.preventDefault();
                    }

                    function onUp() {
                        draggingRef.current = false;
                        document.body.style.userSelect = "";
                        window.removeEventListener("mousemove", onMove);
                        window.removeEventListener("mouseup", onUp);
                        window.removeEventListener("touchmove", onMove);
                        window.removeEventListener("touchend", onUp);
                    }

                    window.addEventListener("mousemove", onMove);
                    window.addEventListener("mouseup", onUp);
                    window.addEventListener("touchmove", onMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onUp);
                    if (e.preventDefault) e.preventDefault();
                }

                function handleFocus(e) {
                    if (onFocus) onFocus();
                }

                return (
                    <div
                        ref={windowRef}
                        className="window border-1 rounded min-w-[300px] bg-black/80 shadow-sm text-white backdrop-blur-md"
                        style={{
                            position: "absolute",
                            left: pos.x + "px",
                            top: pos.y + "px",
                            zIndex: undefined,
                        }}
                        onMouseDown={handleFocus}
                        onTouchStart={handleFocus}
                    >
                        <div
                            className="window__titlebar cursor-grab flex justify-between items-center border-b-1 bg-blue-600/20 rounded-t hover:bg-blue-600/30 backdrop-blur-md"
                            onMouseDown={startDrag}
                            onTouchStart={startDrag}
                        >
                            <div className="flex gap-2 items-center pl-2">
                                {icon && <div>{icon}</div>}
                                <p>{title}</p>
                            </div>

                            <button
                                className="window__titlebar_close w-8 h-8 text-white rounded-full cursor-pointer"
                                onClick={onClose}
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="1em"
                                    height="1em"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
                                    />
                                </svg>
                            </button>
                        </div>
                        <div
                            className="window__content p-2 max-h-[360px]"
                            style={{ overflow: scrollable ? "auto" : "hidden" }}
                        >
                            {content}
                        </div>
                    </div>
                );
            }

            let windows = [];

            function focusWindow(windowObj) {
                windows = windows.filter((w) => w !== windowObj);
                windows.push(windowObj);
                windows.forEach((w, i) => {
                    if (w.container) {
                        w.container.style.zIndex = 1000 + i;
                    }
                });
            }

            function createWindow(title, content, icon, id, scrollable = true) {
                if (id) {
                    const existing = windows.find((w) => w.id === id);
                    if (existing) {
                        focusWindow(existing);
                        return;
                    }
                }

                const container = document.createElement("div");
                container.style.position = "absolute";
                document.body.appendChild(container);

                function closeWindow() {
                    ReactDOM.unmountComponentAtNode(container);
                    document.body.removeChild(container);
                    windows = windows.filter((w) => w.container !== container);
                    // Update z-indexes after removal
                    windows.forEach((w, i) => {
                        if (w.container) {
                            w.container.style.zIndex = 1000 + i;
                        }
                    });
                }

                function handleFocus() {
                    const winObj = windows.find(
                        (w) => w.container === container,
                    );
                    if (winObj) {
                        focusWindow(winObj);
                    }
                }

                ReactDOM.render(
                    <EditWindow
                        title={title}
                        icon={icon}
                        content={content}
                        onClose={closeWindow}
                        onFocus={handleFocus}
                        scrollable={scrollable}
                    />,
                    container,
                );

                const winObj = { container, closeWindow, id };
                windows.push(winObj);
                focusWindow(winObj);
            }

            function Tab({ text, isOpen }) {
                return (
                    <div
                        className={`px-3 py-1 rounded cursor-pointer ${
                            isOpen ? "bg-white/20" : ""
                        }`}
                    >
                        <span>{text}</span>
                    </div>
                );
            }

            function closeWindowById(id) {
                const winObj = windows.find((w) => w.id === id);
                if (winObj) {
                    winObj.closeWindow();
                }
            }

            function createWindowFromSettings(
                widget_type,
                getValue,
                setValue,
                widget_id = 0,
            ) {
                const widget = registeredWidgets[widget_type];
                if (!widget) {
                    console.error(
                        `[Newtab] Unknown widget for settings: ${widget_type}`,
                    );
                    return;
                }

                function SettingsEditorContent() {
                    const defs = widget.settings || {};
                    const [values, setValues] = useState(() => {
                        const out = {};
                        for (const k in defs) {
                            const val = getValue ? getValue(k) : undefined;
                            out[k] =
                                val !== undefined && val !== null
                                    ? val
                                    : defs[k].default;
                        }
                        return out;
                    });

                    useEffect(() => {
                        for (const k in values) {
                            if (setValue) setValue(k, values[k]);
                        }
                    }, []);

                    function updateKey(key, newVal) {
                        setValues((prev) => {
                            const next = { ...prev, [key]: newVal };
                            return next;
                        });
                        if (setValue) setValue(key, newVal);
                    }

                    function resetKey(key) {
                        const def = defs[key];
                        const dv = def && def.default ? def.default : null;
                        updateKey(key, dv);
                    }

                    function renderControl(key) {
                        const def = defs[key];
                        const val = values[key];

                        if (!def) return null;

                        if (def.type === "string") {
                            if (def.typeRefine === "multiline") {
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300 gap-2">
                                            {def.label || key}

                                            <p className="text-zinc-400 text-xs">
                                                {def.placeholders
                                                    ? "(supports {{placeholders}})"
                                                    : ""}
                                            </p>
                                        </label>
                                        <textarea
                                            value={val || ""}
                                            className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm resize-y min-h-[60px]"
                                            onChange={(e) =>
                                                updateKey(key, e.target.value)
                                            }
                                        />
                                    </div>
                                );
                            } else {
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300 gap-2">
                                            {def.label || key}

                                            <p className="text-zinc-400 text-xs">
                                                {def.placeholders
                                                    ? "(supports {{placeholders}})"
                                                    : ""}
                                            </p>
                                        </label>
                                        <input
                                            type="text"
                                            value={val || ""}
                                            className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                            onChange={(e) =>
                                                updateKey(key, e.target.value)
                                            }
                                        />
                                    </div>
                                );
                            }
                        }

                        if (def.type === "number") {
                            if (def.typeRefine === "slider") {
                                const min =
                                    typeof def.min === "number" ? def.min : 0;
                                const max =
                                    typeof def.max === "number" ? def.max : 100;
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300">
                                            {def.label || key}{" "}
                                            <span className="text-xs text-zinc-400 ml-2">
                                                {val}
                                            </span>
                                        </label>
                                        <input
                                            type="range"
                                            min={min}
                                            max={max}
                                            value={val}
                                            className="w-full"
                                            onChange={(e) =>
                                                updateKey(
                                                    key,
                                                    Number(e.target.value || 0),
                                                )
                                            }
                                        />
                                    </div>
                                );
                            } else {
                                return (
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300">
                                            {def.label || key}
                                        </label>
                                        <input
                                            type="number"
                                            value={val}
                                            className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                            onChange={(e) =>
                                                updateKey(
                                                    key,
                                                    Number(e.target.value || 0),
                                                )
                                            }
                                        />
                                    </div>
                                );
                            }
                        }

                        if (def.type === "color") {
                            return (
                                <div className="flex items-center gap-2">
                                    <div className="flex-1">
                                        <label className="text-sm text-zinc-300 block">
                                            {def.label || key}
                                        </label>
                                        <div className="flex gap-2 items-center mt-1">
                                            <input
                                                type="color"
                                                value={val || "#ffffff"}
                                                className="w-10 h-8 rounded border border-zinc-700"
                                                onChange={(e) =>
                                                    updateKey(
                                                        key,
                                                        e.target.value,
                                                    )
                                                }
                                            />
                                            <input
                                                type="text"
                                                value={val || ""}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) =>
                                                    updateKey(
                                                        key,
                                                        e.target.value,
                                                    )
                                                }
                                            />
                                        </div>
                                    </div>
                                </div>
                            );
                        }

                        if (def.type === "font") {
                            const fallbackFonts = [
                                "Arial",
                                "System",
                                "Helvetica",
                                "Inter",
                                "Times New Roman",
                            ];
                            const [localFonts, setLocalFonts] = React.useState(null);

                            React.useEffect(() => {
                                async function fetchLocalFonts() {
                                    if ("queryLocalFonts" in window) {
                                        try {
                                            const fonts = await window.queryLocalFonts();
                                            const fontNames = Array.from(
                                                new Set(
                                                    fonts
                                                        .map((f) => f.family)
                                                        .filter(Boolean)
                                                )
                                            ).sort();
                                            setLocalFonts(fontNames);
                                        } catch (e) {
                                            setLocalFonts(null);
                                        }
                                    }
                                }
                                fetchLocalFonts();
                            }, []);

                            const fontsToShow =
                                localFonts && Array.isArray(localFonts) && localFonts.length > 0
                                    ? localFonts
                                    : fallbackFonts;

                            return (
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm text-zinc-300">
                                        {def.label || key}
                                    </label>
                                    <select
                                        value={val || def.default || fontsToShow[0]}
                                        className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                        onChange={(e) =>
                                            updateKey(key, e.target.value)
                                        }
                                    >
                                        {fontsToShow.map((f) => (
                                            <option key={f} value={f}>
                                                {f}
                                            </option>
                                        ))}
                                    </select>
                                </div>
                            );
                        }

                        if (def.type === "boolean") {
                            return (
                                <div className="flex items-center gap-2">
                                    <label className="text-sm text-zinc-300">
                                        {def.label || key}
                                    </label>
                                    <input
                                        type="checkbox"
                                        checked={!!val}
                                        className="w-5 h-5 accent-blue-600"
                                        onChange={(e) =>
                                            updateKey(key, e.target.checked)
                                        }
                                    />
                                </div>
                            );
                        }

                        if (def.type === "option") {
                            const options = def.options || [];
                            return (
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm text-zinc-300">
                                        {def.label || key}
                                    </label>
                                    <select
                                        value={
                                            val ??
                                            def.default ??
                                            options[0]?.value ??
                                            ""
                                        }
                                        className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                        onChange={(e) =>
                                            updateKey(key, e.target.value)
                                        }
                                    >
                                        {options.map((opt) =>
                                            typeof opt === "object" ? (
                                                <option
                                                    key={opt.value}
                                                    value={opt.value}
                                                >
                                                    {opt.label ?? opt.value}
                                                </option>
                                            ) : (
                                                <option key={opt} value={opt}>
                                                    {opt}
                                                </option>
                                            ),
                                        )}
                                    </select>
                                </div>
                            );
                        }

                        return (
                            <div className="flex flex-col gap-2">
                                <label className="text-sm text-zinc-300">
                                    {def.label || key}
                                </label>
                                <input
                                    type="text"
                                    value={String(val ?? "")}
                                    className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                    onChange={(e) =>
                                        updateKey(key, e.target.value)
                                    }
                                />
                            </div>
                        );
                    }

                    return (
                        <div className="flex flex-col gap-3">
                            <div className="flex flex-col gap-3 p-2 bg-zinc-900/40 rounded">
                                {Object.keys(defs).length === 0 && (
                                    <div className="text-sm text-zinc-400">
                                        No configurable options.
                                    </div>
                                )}

                                {Object.keys(defs).map((k) => (
                                    <div
                                        key={k}
                                        className="flex justify-between items-start gap-2"
                                    >
                                        <div className="flex-1">
                                            {renderControl(k)}
                                        </div>
                                        <div className="flex flex-col gap-2">
                                            <button
                                                className="px-2 py-1 text-xs bg-zinc-700/30 rounded cursor-pointer"
                                                onClick={() => resetKey(k)}
                                            >
                                                Reset
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    );
                }

                createWindow(
                    widget.displayName
                        ? `${widget.displayName} Settings`
                        : `${widget_type} Settings`,
                    <SettingsEditorContent />,
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="1em"
                        height="1em"
                        viewBox="0 0 24 24"
                    >
                        <g
                            fill="none"
                            stroke="currentColor"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                        >
                            <path d="M11 10.27L7 3.34m4 10.39l-4 6.93M12 22v-2m0-18v2m2 8h8m-5 8.66l-1-1.73m1-15.59l-1 1.73M2 12h2m16.66 5l-1.73-1m1.73-9l-1.73 1M3.34 17l1.73-1M3.34 7l1.73 1" />
                            <circle cx="12" cy="12" r="2" />
                            <circle cx="12" cy="12" r="8" />
                        </g>
                    </svg>,
                    `settings-${widget_id}`,
                    true,
                );
            }

            function openBackgroundEditor() {
                function BackgroundEditorContent({ onClose }) {
                    const [bgMode, setBgMode] = useState(() => {
                        const bgData = localStorage.getItem("prefs_bg");
                        if (bgData) {
                            const bgObj = JSON.parse(bgData);
                            return bgObj.type;
                        }
                        return "solidcolor";
                    });

                    const modes = [
                        { key: "solidcolor", label: "Color" },
                        { key: "gradient", label: "Gradient" },
                        { key: "image", label: "Image" },
                    ];

                    const curBgSolid =
                        JSON.parse(localStorage.getItem("prefs_bg") || "{}") ||
                        {};
                    const solidColor = curBgSolid.color || "#000000";

                    const curBgGradient =
                        JSON.parse(localStorage.getItem("prefs_bg") || "{}") ||
                        {};
                    const gradientAngle = curBgGradient.angle ?? 90;
                    const gradientColors = curBgGradient.colors || [
                        "#2563eb",
                        "#1e293b",
                    ];

                    function decodeProxyUrl(proxyUrl) {
                        console.log(proxyUrl);
                        try {
                            return decodeURIComponent(
                                atob(proxyUrl.split("url=")[1]),
                            );
                        } catch {
                            return "";
                        }
                    }
                    function encodeProxyUrl(url) {
                        if (!url) return "";
                        return "/proxy?url=" + btoa(encodeURIComponent(url));
                    }
                    const curBgImage =
                        JSON.parse(localStorage.getItem("prefs_bg") || "{}") ||
                        {};
                    const [inputUrl, setInputUrl] = useState(
                        decodeProxyUrl(curBgImage.url),
                    );

                    function applyColor(value) {
                        const newBg = {
                            type: "solidcolor",
                            color: value,
                        };
                        localStorage.setItem("prefs_bg", JSON.stringify(newBg));
                        document.body.style.background = bg_to_css(newBg);
                    }

                    function updateGradient() {
                        const elAngle = document.querySelector(
                            "[data-bg-gradient-angle]",
                        );
                        const elC1 = document.querySelector(
                            "[data-bg-gradient-c1]",
                        );
                        const elC2 = document.querySelector(
                            "[data-bg-gradient-c2]",
                        );
                        const a = Number((elAngle && elAngle.value) || 90);
                        const c1 = (elC1 && elC1.value) || "#2563eb";
                        const c2 = (elC2 && elC2.value) || "#1e293b";
                        const newBg = {
                            type: "gradient",
                            angle: a,
                            colors: [c1, c2],
                        };
                        localStorage.setItem("prefs_bg", JSON.stringify(newBg));
                        document.body.style.background = bg_to_css(newBg);
                    }

                    function handleImageUrlChange(e) {
                        const v = e.target.value;
                        setInputUrl(v);
                        const newBg = { type: "image", url: encodeProxyUrl(v) };
                        localStorage.setItem("prefs_bg", JSON.stringify(newBg));
                        document.body.style.background = bg_to_css(newBg);
                    }

                    function handleTabClick(modeKey) {
                        setBgMode(modeKey);

                        let newBg;
                        if (modeKey === "solidcolor") {
                            newBg = {
                                type: "solidcolor",
                                color: solidColor,
                            };
                        } else if (modeKey === "gradient") {
                            newBg = {
                                type: "gradient",
                                angle: gradientAngle,
                                colors: gradientColors,
                            };
                        } else if (modeKey === "image") {
                            newBg = {
                                type: "image",
                                url: curBgImage.url || "",
                            };
                        }
                        if (newBg) {
                            localStorage.setItem(
                                "prefs_bg",
                                JSON.stringify(newBg),
                            );
                            document.body.style.background = bg_to_css(newBg);
                        }
                    }

                    return (
                        <div className="flex flex-col gap-2">
                            <div>
                                <div className="flex gap-2 my-1 justify-center">
                                    {modes.map((mode) => (
                                        <div
                                            key={mode.key}
                                            className={`px-3 py-1 rounded cursor-pointer transition ${
                                                bgMode === mode.key
                                                    ? "bg-blue-600/40 text-white"
                                                    : "bg-zinc-700/30 text-zinc-300"
                                            }`}
                                            onClick={() =>
                                                handleTabClick(mode.key)
                                            }
                                        >
                                            {mode.label}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {bgMode === "solidcolor" && (
                                <div className="flex flex-col gap-3 bg-zinc-900/40 p-3 rounded">
                                    <div className="flex items-center gap-3">
                                        <div className="flex items-center gap-2">
                                            <input
                                                data-bg-solid-color
                                                aria-label="Solid color"
                                                type="color"
                                                defaultValue={solidColor}
                                                className="w-12 h-8 p-0 rounded border border-zinc-700"
                                                onChange={(e) =>
                                                    applyColor(e.target.value)
                                                }
                                            />
                                            <input
                                                data-bg-solid-hex
                                                aria-label="Hex input"
                                                type="text"
                                                defaultValue={solidColor}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) =>
                                                    applyColor(e.target.value)
                                                }
                                            />
                                        </div>
                                    </div>
                                </div>
                            )}

                            {bgMode === "gradient" && (
                                <div className="flex flex-col gap-3 bg-zinc-900/40 p-3 rounded">
                                    <div className="flex flex-col gap-2">
                                        <label className="text-sm text-zinc-300">
                                            Angle:{" "}
                                            <span className="text-xs text-zinc-400 ml-2">
                                                {gradientAngle}°
                                            </span>
                                        </label>
                                        <input
                                            data-bg-gradient-angle
                                            type="range"
                                            min="0"
                                            max="360"
                                            defaultValue={gradientAngle}
                                            className="w-full"
                                            onChange={updateGradient}
                                        />
                                    </div>

                                    <div className="flex gap-3 items-center">
                                        <div className="flex items-center gap-2">
                                            <input
                                                data-bg-gradient-c1
                                                type="color"
                                                defaultValue={gradientColors[0]}
                                                className="w-10 h-8 rounded border border-zinc-700"
                                                onChange={updateGradient}
                                            />
                                            <input
                                                type="text"
                                                defaultValue={gradientColors[0]}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) => {
                                                    const elC1 =
                                                        document.querySelector(
                                                            "[data-bg-gradient-c1]",
                                                        );
                                                    if (elC1)
                                                        elC1.value =
                                                            e.target.value;
                                                    updateGradient();
                                                }}
                                            />
                                        </div>

                                        <div className="flex items-center gap-2">
                                            <input
                                                data-bg-gradient-c2
                                                type="color"
                                                defaultValue={gradientColors[1]}
                                                className="w-10 h-8 rounded border border-zinc-700"
                                                onChange={updateGradient}
                                            />
                                            <input
                                                type="text"
                                                defaultValue={gradientColors[1]}
                                                className="bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm w-28"
                                                onChange={(e) => {
                                                    const elC2 =
                                                        document.querySelector(
                                                            "[data-bg-gradient-c2]",
                                                        );
                                                    if (elC2)
                                                        elC2.value =
                                                            e.target.value;
                                                    updateGradient();
                                                }}
                                            />
                                        </div>
                                    </div>
                                </div>
                            )}

                            {bgMode === "image" && (
                                <div className="flex flex-col gap-3 bg-zinc-900/40 p-3 rounded">
                                    <label className="text-sm text-zinc-300">
                                        Image URL
                                    </label>
                                    <div className="flex gap-2">
                                        <input
                                            data-bg-image-url
                                            type="text"
                                            placeholder="https://example.com/image.jpg"
                                            value={inputUrl}
                                            className="flex-1 bg-transparent border border-zinc-700 rounded px-2 py-1 text-sm"
                                            onChange={handleImageUrlChange}
                                        />
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                }

                createWindow(
                    "Background",
                    <BackgroundEditorContent />,
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="1em"
                        height="1em"
                        viewBox="0 0 24 24"
                    >
                        <path
                            fill="currentColor"
                            d="M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10a2.5 2.5 0 0 0 2.5-2.5c0-.61-.23-1.2-.64-1.67a.53.53 0 0 1-.13-.33c0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6c0-4.96-4.49-9-10-9m5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5m-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9M5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13S5 12.33 5 11.5m6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5S8.67 6 9.5 6s1.5.67 1.5 1.5"
                        />
                    </svg>,
                    "edit-bg-window",
                );
            }

            function openWidgetCreator() {
                function WidgetCreator() {
                    const [_, setTick] = React.useState(0);
                    const dragStateRef = React.useRef({
                        dragging: false,
                        widgetKey: null,
                        startX: 0,
                        startY: 0,
                        lastX: 0,
                        lastY: 0,
                        windowRect: null,
                        previewContainer: null,
                        previewShown: false,
                    });

                    useEffectCleanup();

                    function useEffectCleanup() {
                        React.useEffect(() => {
                            return () => {
                                const st = dragStateRef.current;
                                if (st.previewContainer) {
                                    try {
                                        ReactDOM.unmountComponentAtNode(
                                            st.previewContainer,
                                        );
                                        document.body.removeChild(
                                            st.previewContainer,
                                        );
                                    } catch (e) {}
                                    st.previewContainer = null;
                                    st.previewShown = false;
                                }
                                st.dragging = false;
                                st.widgetKey = null;
                            };
                        }, []);
                    }

                    function onPointerDown(e, w) {
                        if (e.button === 2) return;
                        const st = dragStateRef.current;
                        st.dragging = true;
                        st.widgetKey = w;
                        const point = getPointFromEvent(e);
                        st.startX = point.x;
                        st.startY = point.y;
                        st.lastX = point.x;
                        st.lastY = point.y;

                        const el =
                            (e.currentTarget &&
                                e.currentTarget.closest &&
                                e.currentTarget.closest(".window")) ||
                            null;
                        st.windowRect = el ? el.getBoundingClientRect() : null;

                        window.addEventListener("mousemove", onPointerMove);
                        window.addEventListener("mouseup", onPointerUp);
                        window.addEventListener("touchmove", onPointerMove, {
                            passive: false,
                        });
                        window.addEventListener("touchend", onPointerUp);

                        if (e.preventDefault) e.preventDefault();
                    }

                    function onPointerMove(e) {
                        const st = dragStateRef.current;
                        if (!st.dragging) return;
                        const point = getPointFromEvent(e);
                        st.lastX = point.x;
                        st.lastY = point.y;

                        const leftWindow =
                            st.windowRect &&
                            (point.x < st.windowRect.left ||
                                point.x > st.windowRect.right ||
                                point.y < st.windowRect.top ||
                                point.y > st.windowRect.bottom);

                        if (leftWindow && !st.previewShown) {
                            showPreviewAt(point.x, point.y, st.widgetKey);
                            st.previewShown = true;
                        } else if (!leftWindow && st.previewShown) {
                            removePreview();
                            st.previewShown = false;
                        } else if (st.previewShown) {
                            updatePreviewPosition(point.x, point.y);
                        }

                        if (e.preventDefault) e.preventDefault();
                    }

                    function onPointerUp(e) {
                        const st = dragStateRef.current;
                        if (!st.dragging) return;
                        const point = getPointFromEvent(e);

                        if (st.previewShown && st.previewContainer) {
                            const size = getWidgetSize(st.widgetKey);
                            const left = point.x - size[0] / 2;
                            const top = point.y - size[1] / 2;

                            createWidgetInstance(
                                st.widgetKey,
                                pixelsToPercentX(Math.max(0, Math.round(left))),
                                pixelsToPercentY(Math.max(0, Math.round(top))),
                                size[0],
                                size[1],
                            );

                            removePreview();
                            updateWidgetRenders();
                        } else {
                            const size = getWidgetSize(st.widgetKey);
                            const maxX = Math.max(
                                window.innerWidth - size[0],
                                0,
                            );
                            const maxY = Math.max(
                                window.innerHeight - size[1],
                                0,
                            );
                            const randLeft = Math.round(Math.random() * maxX);
                            const randTop = Math.round(Math.random() * maxY);

                            createWidgetInstance(
                                st.widgetKey,
                                pixelsToPercentX(randLeft),
                                pixelsToPercentY(randTop),
                                size[0],
                                size[1],
                            );
                        }

                        cleanupListeners();
                        st.dragging = false;
                        st.widgetKey = null;
                        st.previewShown = false;
                        if (e.preventDefault) e.preventDefault();
                    }

                    function cleanupListeners() {
                        window.removeEventListener("mousemove", onPointerMove);
                        window.removeEventListener("mouseup", onPointerUp);
                        window.removeEventListener("touchmove", onPointerMove);
                        window.removeEventListener("touchend", onPointerUp);
                    }

                    function getPointFromEvent(e) {
                        if (e.type && e.type.startsWith("touch")) {
                            const t =
                                e.touches && e.touches[0]
                                    ? e.touches[0]
                                    : e.changedTouches && e.changedTouches[0]
                                      ? e.changedTouches[0]
                                      : null;
                            return {
                                x: t ? t.clientX : 0,
                                y: t ? t.clientY : 0,
                            };
                        } else {
                            return { x: e.clientX, y: e.clientY };
                        }
                    }

                    function getWidgetSize(w) {
                        const def = registeredWidgets[w];
                        if (!def) return [150, 60];
                        const s = def.initialSize || [150, 60];
                        return [s[0] || 150, s[1] || 60];
                    }

                    function showPreviewAt(x, y, w) {
                        removePreview();
                        const size = getWidgetSize(w);
                        const container = document.createElement("div");
                        container.style.position = "fixed";
                        container.style.left = "0px";
                        container.style.top = "0px";
                        container.style.width = size[0] + "px";
                        container.style.height = size[1] + "px";
                        container.style.pointerEvents = "none";
                        container.style.opacity = "0.65";
                        container.style.transform = `translate(${x - size[0] / 2}px, ${y - size[1] / 2}px)`;
                        container.style.zIndex = "2000";
                        document.body.appendChild(container);

                        const WidgetComp = registeredWidgets[w].component;
                        try {
                            ReactDOM.render(
                                React.createElement(WidgetComp, {
                                    opts: getWidgetInstanceOpts(w) || {},
                                }),
                                container,
                            );
                        } catch (e) {
                            container.textContent =
                                registeredWidgets[w].displayName || w;
                            container.style.display = "flex";
                            container.style.alignItems = "center";
                            container.style.justifyContent = "center";
                            container.style.background =
                                "rgba(255,255,255,0.04)";
                            container.style.color = "#fff";
                            container.style.borderRadius = "6px";
                            container.style.padding = "4px";
                            container.style.boxSizing = "border-box";
                        }

                        dragStateRef.current.previewContainer = container;
                        dragStateRef.current.previewShown = true;
                    }

                    function updatePreviewPosition(x, y) {
                        const st = dragStateRef.current;
                        if (!st.previewContainer) return;
                        const size = getWidgetSize(st.widgetKey);
                        st.previewContainer.style.transform = `translate(${x - size[0] / 2}px, ${y - size[1] / 2}px)`;
                    }

                    function removePreview() {
                        const st = dragStateRef.current;
                        if (st.previewContainer) {
                            try {
                                ReactDOM.unmountComponentAtNode(
                                    st.previewContainer,
                                );
                                if (st.previewContainer.parentNode)
                                    st.previewContainer.parentNode.removeChild(
                                        st.previewContainer,
                                    );
                            } catch (e) {}
                            st.previewContainer = null;
                            st.previewShown = false;
                        }
                    }

                    return (
                        <div className="grid grid-col grid-cols-2">
                            {Object.keys(registeredWidgets).map((w) => (
                                <div
                                    key={w}
                                    className="flex flex-col items-center p-3 m-2 bg-zinc-800/30 hover:bg-zinc-700/40 rounded cursor-grab"
                                    onMouseDown={(e) => onPointerDown(e, w)}
                                    onTouchStart={(e) => onPointerDown(e, w)}
                                    role="button"
                                >
                                    <div className="text-sm text-center select-none">
                                        {registeredWidgets[w].displayName || w}
                                    </div>
                                </div>
                            ))}
                        </div>
                    );
                }

                createWindow(
                    "New widget",
                    <WidgetCreator />,
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="1em"
                        height="1em"
                        viewBox="0 0 24 24"
                    >
                        <g
                            fill="none"
                            stroke="currentColor"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                        >
                            <path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" />
                            <path d="m3.3 7l8.7 5l8.7-5M12 22V12" />
                        </g>
                    </svg>,
                    "new-widget-window",
                );
            }

            function EditModeToggle({ editModeSetState }) {
                const [editMode, setEditMode] = React.useState(isEditMode);

                function handleClick() {
                    isEditMode = !isEditMode;
                    setEditMode(isEditMode);
                    editModeSetState(isEditMode);
                    if (isEditMode) {
                        windows.forEach((w) => {
                            w.closeWindow();
                        });
                        windows = [];
                        openBackgroundEditor();
                        openWidgetCreator();

                        localStorage.setItem("prefs_first_time", "false");
                    } else {
                        windows.forEach((w) => {
                            w.closeWindow();
                        });
                        windows = [];
                    }
                }

                return (
                    <div
                        onClick={handleClick}
                        className="absolute bottom-4 right-4 p-3 bg-zinc-800/30 hover:bg-blue-600/30 backdrop-blur-md rounded-full flex items-center justify-center cursor-pointer"
                    >
                        <div>
                            {editMode ? (
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20px"
                                    height="20px"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
                                    />
                                </svg>
                            ) : (
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20px"
                                    height="20px"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83l3.75 3.75z"
                                    />
                                </svg>
                            )}
                        </div>
                    </div>
                );
            }

            function WidgetWrapper(widget) {
                const [opts, setOpts] = useState(() => {
                    return getWidgetInstanceOpts(widget.id) || {};
                });

                useEffect(() => {
                    function handleStorageEvent(e) {
                        if (e.key === `widget_opts_${widget.id}`) {
                            const newOpts =
                                getWidgetInstanceOpts(widget.id) || {};
                            setOpts(newOpts);
                        }
                    }
                    window.addEventListener("storage", handleStorageEvent);
                    return () => {
                        window.removeEventListener(
                            "storage",
                            handleStorageEvent,
                        );
                    };
                }, [widget.id]);

                const dragRef = React.useRef(null);
                const resizeRef = React.useRef(null);

                function onDragStart(e) {
                    if (e.button === 2) return;
                    const startPoint = getPointFromEvent(e);
                    dragRef.current = {
                        dragging: true,
                        startX: startPoint.x,
                        startY: startPoint.y,
                        origX: widget.x,
                        origY: widget.y,
                        width: widget.width,
                        height: widget.height,
                    };

                    document.body.style.userSelect = "none";

                    window.addEventListener("mousemove", onDragMove);
                    window.addEventListener("mouseup", onDragEnd);
                    window.addEventListener("touchmove", onDragMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onDragEnd);

                    if (e.preventDefault) e.preventDefault();
                }

                function onDragMove(e) {
                    if (!dragRef.current || !dragRef.current.dragging) return;
                    const point = getPointFromEvent(e);
                    const dx = point.x - dragRef.current.startX;
                    const dy = point.y - dragRef.current.startY;

                    const newX = dragRef.current.origX + pixelsToPercentX(dx);
                    const newY = dragRef.current.origY + pixelsToPercentY(dy);

                    const clampedX = Math.max(0, Math.min(newX, 100));
                    const clampedY = Math.max(0, Math.min(newY, 100));

                    updateWidgetPosition(widget.id, clampedX, clampedY);
                    updateWidgetRenders();

                    if (e.preventDefault) e.preventDefault();
                }

                function onDragEnd(e) {
                    document.body.style.userSelect = "";
                    dragRef.current = { ...dragRef.current, dragging: false };
                    window.removeEventListener("mousemove", onDragMove);
                    window.removeEventListener("mouseup", onDragEnd);
                    window.removeEventListener("touchmove", onDragMove);
                    window.removeEventListener("touchend", onDragEnd);
                    if (e.preventDefault) e.preventDefault();
                }

                function onResizeStart(e) {
                    if (e.button === 2) return;
                    const startPoint = getPointFromEvent(e);
                    resizeRef.current = {
                        resizing: true,
                        startX: startPoint.x,
                        startY: startPoint.y,
                        origWidth: widget.width,
                        origHeight: widget.height,
                    };

                    document.body.style.userSelect = "none";

                    window.addEventListener("mousemove", onResizeMove);
                    window.addEventListener("mouseup", onResizeEnd);
                    window.addEventListener("touchmove", onResizeMove, {
                        passive: false,
                    });
                    window.addEventListener("touchend", onResizeEnd);

                    if (e.preventDefault) e.preventDefault();
                }

                function onResizeMove(e) {
                    if (!resizeRef.current || !resizeRef.current.resizing)
                        return;
                    const point = getPointFromEvent(e);
                    const dx = point.x - resizeRef.current.startX;
                    const dy = point.y - resizeRef.current.startY;

                    const bounds = registeredWidgets[widget.type]?.bounds || [
                        [800, 600],
                        [50, 30],
                    ];
                    const [[maxWidth, maxHeight], [minWidth, minHeight]] =
                        bounds;

                    const newWidth = Math.max(
                        minWidth,
                        resizeRef.current.origWidth + dx,
                    );
                    const newHeight = Math.max(
                        minHeight,
                        resizeRef.current.origHeight + dy,
                    );

                    const availableWidth =
                        window.innerWidth -
                        (widget.x / 100) * window.innerWidth;
                    const availableHeight =
                        window.innerHeight -
                        (widget.y / 100) * window.innerHeight;

                    const clampedWidth = Math.min(
                        newWidth,
                        Math.min(maxWidth, availableWidth),
                    );
                    const clampedHeight = Math.min(
                        newHeight,
                        Math.min(maxHeight, availableHeight),
                    );

                    updateWidgetSize(widget.id, clampedHeight, clampedWidth);
                    updateWidgetRenders();

                    if (e.preventDefault) e.preventDefault();
                }

                function onResizeEnd(e) {
                    document.body.style.userSelect = "";
                    resizeRef.current = {
                        ...resizeRef.current,
                        resizing: false,
                    };
                    window.removeEventListener("mousemove", onResizeMove);
                    window.removeEventListener("mouseup", onResizeEnd);
                    window.removeEventListener("touchmove", onResizeMove);
                    window.removeEventListener("touchend", onResizeEnd);
                    if (e.preventDefault) e.preventDefault();
                }

                function getPointFromEvent(e) {
                    if (e.type && e.type.startsWith("touch")) {
                        const t =
                            e.touches && e.touches[0]
                                ? e.touches[0]
                                : e.changedTouches && e.changedTouches[0]
                                  ? e.changedTouches[0]
                                  : null;
                        return {
                            x: t ? t.clientX : 0,
                            y: t ? t.clientY : 0,
                        };
                    } else {
                        return { x: e.clientX || 0, y: e.clientY || 0 };
                    }
                }

                function onDeleteClick(e) {
                    if (e.preventDefault) e.preventDefault();
                    deleteWidgetInstance(widget.id);
                    updateWidgetRenders();
                }

                function onEditClick(e) {
                    if (e.preventDefault) e.preventDefault();
                    createWindowFromSettings(
                        widget.type,
                        (k) => opts[k],
                        (k, v) => {
                            console.log("Value change:", k, "to", v);
                            setWidgetInstanceOpts(widget.id, {
                                [k]: v,
                            });
                        },
                        widget.id,
                    );
                }

                const WidgetComp = registeredWidgets[widget.type].component;
                if (!WidgetComp) {
                    console.error(
                        `Widget component is undefined for widget:`,
                        widget,
                    );
                    return (
                        <div
                            id={"widget_" + widget.id}
                            className="newtab__widget absolute"
                            style={{
                                left: widget.x + "%",
                                top: widget.y + "%",
                                width: widget.width + "px",
                                height: widget.height + "px",
                            }}
                        >
                            Error: Widget component not found
                        </div>
                    );
                }
                return (
                    <div
                        id={"widget_" + widget.id}
                        className={`newtab__widget absolute ${widget.editMode ? "border-2 border-blue-500/50" : ""}`}
                        style={{
                            left: widget.x + "%",
                            top: widget.y + "%",
                            width: widget.width + "px",
                            height: widget.height + "px",
                        }}
                    >
                        {widget.editMode && (
                            <>
                                <div className="absolute flex gap-1 -top-8 right-0 z-10 hover:bg-blue-600/40 transition-all duration-100 bg-blue-600/20 backdrop-blur-sm rounded p-1">
                                    <div
                                        className="newtab_widget_edit cursor-pointer"
                                        onClick={onEditClick}
                                        title="Settings"
                                        style={{
                                            display: "flex",
                                            alignItems: "center",
                                        }}
                                    >
                                        <svg
                                            xmlns="http://www.w3.org/2000/svg"
                                            width="1em"
                                            height="1em"
                                            viewBox="0 0 24 24"
                                        >
                                            <g
                                                fill="none"
                                                stroke="currentColor"
                                                stroke-linecap="round"
                                                stroke-linejoin="round"
                                                stroke-width="2"
                                            >
                                                <path d="M11 10.27L7 3.34m4 10.39l-4 6.93M12 22v-2m0-18v2m2 8h8m-5 8.66l-1-1.73m1-15.59l-1 1.73M2 12h2m16.66 5l-1.73-1m1.73-9l-1.73 1M3.34 17l1.73-1M3.34 7l1.73 1" />
                                                <circle cx="12" cy="12" r="2" />
                                                <circle cx="12" cy="12" r="8" />
                                            </g>
                                        </svg>
                                    </div>

                                    <div
                                        className="newtab_widget_delete cursor-pointer"
                                        onClick={onDeleteClick}
                                        title="Delete"
                                        style={{
                                            display: "flex",
                                            alignItems: "center",
                                        }}
                                    >
                                        <svg
                                            xmlns="http://www.w3.org/2000/svg"
                                            width="1em"
                                            height="1em"
                                            viewBox="0 0 24 24"
                                        >
                                            <path
                                                fill="none"
                                                stroke="currentColor"
                                                stroke-linecap="round"
                                                stroke-linejoin="round"
                                                stroke-width="2"
                                                d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
                                            />
                                        </svg>
                                    </div>

                                    <div
                                        className="newtab_widget_drag_handle cursor-grab"
                                        onMouseDown={onDragStart}
                                        onTouchStart={onDragStart}
                                        title="Drag"
                                        style={{
                                            display: "flex",
                                            alignItems: "center",
                                        }}
                                    >
                                        <svg
                                            xmlns="http://www.w3.org/2000/svg"
                                            width="1em"
                                            height="1em"
                                            viewBox="0 0 24 24"
                                        >
                                            <path
                                                fill="none"
                                                stroke="currentColor"
                                                stroke-linecap="round"
                                                stroke-linejoin="round"
                                                stroke-width="2.5"
                                                d="M8 6h.006M8 12h.006M8 18h.006m7.988-12H16m-.006 6H16m-.006 6H16"
                                            />
                                        </svg>
                                    </div>
                                </div>
                            </>
                        )}

                        {widget.editMode && (
                            <div
                                className="absolute bottom-0 right-0 w-4 h-4 bg-blue-500/50 z-100 cursor-nw-resize"
                                onMouseDown={onResizeStart}
                                onTouchStart={onResizeStart}
                                title="Resize"
                                style={{
                                    clipPath:
                                        "polygon(100% 0, 0 100%, 100% 100%)",
                                }}
                            />
                        )}

                        <WidgetComp opts={opts} />
                    </div>
                );
            }

            function App() {
                const [editModeState, setEditModeState] = useState(false);
                const [widgetsState, setWidgetsState] = useState(widgets);

                useEffect(() => {
                    rerender_widgets = () => {
                        setWidgetsState([...widgets]);
                    };

                    return () => {
                        rerender_widgets = () => {
                            console.warn("[Newtab] Component unmounted.");
                        };
                    };
                }, []);

                return (
                    <>
                        {widgetsState.map((widget, idx) => (
                            <WidgetWrapper
                                key={[Object.values(widget.opts), idx]}
                                {...widget}
                                editMode={editModeState}
                            />
                        ))}
                        <EditModeToggle editModeSetState={setEditModeState} />
                    </>
                );
            }

            if (isFirstTime) {
                function FirstTimeTutorial() {
                    return (
                        <div className="p-4 text-white">
                            <h2 className="text-xl mb-4">
                                Welcome to New Tab!
                            </h2>
                            <p className="mb-2">
                                It looks like this is your first time here!
                                <br />
                                <br /> To get started click the edit button at
                                the bottom right to enter edit mode. <br />
                                <br /> In edit mode you will be able to add
                                widgets and customize your new tab page.
                            </p>
                        </div>
                    );
                }
                createWindow(
                    "Tutorial",
                    <FirstTimeTutorial />,
                    null,
                    "tutorial",
                );
            }

            ReactDOM.render(<App />, document.getElementById("root"));
        </script>
    </body>
</html>
